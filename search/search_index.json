{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/","title":"Contributing","text":"<p>Spice is a community-driven project. This means that we are open for feature requests or suggestions for improvement. Apart from that, feel free to fork this project and send us some code contributions via pull request.</p> <p>In every case please read the Code of Conduct before contributing.</p>"},{"location":"contributing/#security-issues","title":"Security issues","text":"<p>Please do not open issues regrading security on GitHub! Please read our Security Policy and contact us via non-public ways, e.g. per mail: contact@chillibits.com.</p>"},{"location":"contributing/#feature-request-and-bugs","title":"Feature request and bugs","text":"<p>If you want to contribute by reporting a bug (except a security issue) or you want to send in a feature request, please navigate to the issues section. Issues that are easy to work on and appropriate for beginners are marked as 'good first issue'. Feel free to claim one of those issues by commenting that you want to do so. After we assign you to the issue, you can start working on the problem / feature request. Please open a pull request when you're done with the work and please only work on one issue at once.</p>"},{"location":"intro/","title":"Introduction","text":"<p>Spice is a compiled language which sets a focus on performance and practicality. It is considered as a systems language, which means that is rather not suitable for coding user interfaces, but for coding drivers and cli tools. Spice has support for cross-compiling for multiple target platforms. In order to get started, visit the installation guide.</p>"},{"location":"cli/build/","title":"Build subcommand","text":"<p>The <code>build</code> subcommand can be used to compile your Spice project to an executable file and save it to the current directory.</p>"},{"location":"cli/build/#usage","title":"Usage","text":"Long formShort form <p>Use the <code>build</code> subcommand by executing: Bash<pre><code>$ spice build [options] &lt;main-source-file&gt;\n</code></pre></p> <p>Use the <code>build</code> command by executing: Bash<pre><code>$ spice b [options] &lt;mail-source-file&gt;\n</code></pre></p>"},{"location":"cli/build/#options","title":"Options","text":"<p>You can apply following options to the <code>build</code> subcommand:</p> Option Long Description <code>-d</code> <code>--debug-output</code> Print compiler output for debugging. <code>-cst</code> <code>--dump-cst</code> Dump CST as serialized string and SVG image <code>-ast</code> <code>--dump-ast</code> Dump AST as serialized string and SVG image - <code>--dump-symtab</code> Dump serialized symbol tables - <code>--dump-types</code> Dump all used types - <code>--dump-cache-stats</code> Dump stats for compiler-internal lookup caches <code>-ir</code> <code>--dump-ir</code> Dump LLVM-IR <code>-s</code>, <code>-asm</code> <code>--dump-assembly</code> Dump Assembly code - <code>--dump-object-file</code> Dump object files - <code>--dump-dependency-graph</code> Dump compile unit dependency graph - <code>--dump-to-files</code> Redirect all dumps to files instead of printing them to the screen - <code>--abort-after-dump</code> Abort the compilation process after dumping the first requested resource <code>-j &lt;n&gt;</code> <code>--jobs &lt;n&gt;</code> Set number of jobs to parallelize compilation (default is auto) <code>-t</code> <code>--target</code> Target triple for the emitted executable (for cross-compiling).  Format: <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> <code>-o</code> <code>--output</code> Set path for executable output. <code>-O&lt;n&gt;</code> - Set optimization level.  Valid options: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Oz</code> <code>-m</code> <code>--build-mode</code> Controls the build mode. Valid values are <code>debug</code>, <code>release</code> and <code>test</code>. <code>-lto</code> - Enable link-time-optimization <code>-g</code> <code>--debug-info</code> Generate debug info to debug the executable in GDB, etc. - <code>--static</code> Produce stand-alone executable by linking statically - <code>--no-entry</code> Do not require or generate main function (useful for web assembly target) - <code>--disable-verifier</code> Disable LLVM module and function verification (only recommended for debugging the compiler) - <code>--ignore-cache</code> Compile always and ignore the compile cache - <code>--use-lifetime-markers</code> Generate lifetime markers to enhance optimizations"},{"location":"cli/install/","title":"Install subcommand","text":"<p>The <code>install</code> subcommand can be used to compile your Spice project to an executable file and copy it to a binary directory in the PATH variable.</p>"},{"location":"cli/install/#usage","title":"Usage","text":"Long formShort form <p>Use the <code>install</code> subcommand by executing: Bash<pre><code>$ spice install [options] &lt;main-source-file&gt;\n</code></pre></p> <p>Use the <code>install</code> subcommand by executing: Bash<pre><code>$ spice i [options] &lt;mail-source-file&gt;\n</code></pre></p>"},{"location":"cli/install/#options","title":"Options","text":"<p>You can apply following options to the <code>install</code> subcommand:</p> Option Long Description <code>-d</code> <code>--debug-output</code> Print compiler output for debugging. <code>-cst</code> <code>--dump-cst</code> Dump CST as serialized string and SVG image <code>-ast</code> <code>--dump-ast</code> Dump AST as serialized string and SVG image - <code>--dump-symtab</code> Dump serialized symbol tables - <code>--dump-types</code> Dump all used types - <code>--dump-cache-stats</code> Dump stats for compiler-internal lookup caches <code>-ir</code> <code>--dump-ir</code> Dump LLVM-IR <code>-s</code>, <code>-asm</code> <code>--dump-assembly</code> Dump Assembly code - <code>--dump-object-file</code> Dump object files - <code>--dump-dependency-graph</code> Dump compile unit dependency graph <code>-d</code> <code>--debug-output</code> Print compiler output for debugging. <code>-j &lt;n&gt;</code> <code>--jobs &lt;n&gt;</code> Set number of jobs to parallelize compilation (Default is auto) <code>-o</code> <code>--output</code> Set path for executable output. <code>-O&lt;n&gt;</code> - Set optimization level.  Valid options: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Oz</code> <code>-m</code> <code>--build-mode</code> Controls the build mode. Valid values are <code>debug</code> and <code>release</code> - <code>--ignore-cache</code> Compile always and ignore the compile cache - <code>--use-lifetime-markers</code> Generate lifetime markers to enhance optimizations"},{"location":"cli/run/","title":"Run subcommand","text":"<p>The <code>run</code> subcommand can be used to compile your Spice project to an executable file and run it immediately.</p>"},{"location":"cli/run/#usage","title":"Usage","text":"Long formShort form <p>Use the <code>run</code> subcommand by executing: Bash<pre><code>$ spice run [options] &lt;main-source-file&gt;\n</code></pre></p> <p>Use the <code>run</code> subcommand by executing: Bash<pre><code>$ spice r [options] &lt;main-source-file&gt;\n</code></pre></p>"},{"location":"cli/run/#options","title":"Options","text":"<p>You can apply following options to the <code>run</code> subcommand:</p> Option Long Description <code>-d</code> <code>--debug-output</code> Print compiler output for debugging. <code>-cst</code> <code>--dump-cst</code> Dump CST as serialized string and SVG image <code>-ast</code> <code>--dump-ast</code> Dump AST as serialized string and SVG image - <code>--dump-symtab</code> Dump serialized symbol tables - <code>--dump-types</code> Dump all used types - <code>--dump-cache-stats</code> Dump stats for compiler-internal lookup caches <code>-ir</code> <code>--dump-ir</code> Dump LLVM-IR <code>-s</code>, <code>-asm</code> <code>--dump-assembly</code> Dump Assembly code - <code>--dump-object-file</code> Dump object files - <code>--dump-dependency-graph</code> Dump compile unit dependency graph <code>-j &lt;n&gt;</code> <code>--jobs &lt;n&gt;</code> Set number of jobs to parallelize compilation (default is auto) <code>-o</code> <code>--output</code> Set path for executable output. <code>-O&lt;x&gt;</code> - Set optimization level.  Valid options: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Oz</code> <code>-m</code> <code>--build-mode</code> Controls the build mode. Valid values are <code>debug</code> and <code>release</code> <code>-g</code> <code>--debug-info</code> Generate debug info to debug the executable in GDB, etc. - <code>--disable-verifier</code> Disable LLVM module and function verification (only recommended for debugging the compiler) - <code>--ignore-cache</code> Compile always and ignore the compile cache - <code>--use-lifetime-markers</code> Generate lifetime markers to enhance optimizations"},{"location":"cli/test/","title":"Test subcommand","text":"<p>The <code>test</code> subcommand can be used to run individual tests or the whole test suite.</p>"},{"location":"cli/test/#usage","title":"Usage","text":"Long formShort form <p>Use the <code>test</code> subcommand by executing: Bash<pre><code>$ spice test [options] &lt;test-source-file&gt;\n</code></pre></p> <p>Use the <code>test</code> subcommand by executing: Bash<pre><code>$ spice t [options] &lt;test-source-file&gt;\n</code></pre></p>"},{"location":"cli/test/#options","title":"Options","text":"<p>You can apply following options to the <code>test</code> subcommand:</p> Option Long Description <code>-d</code> <code>--debug-output</code> Print compiler output for debugging. <code>-cst</code> <code>--dump-cst</code> Dump CST as serialized string and SVG image <code>-ast</code> <code>--dump-ast</code> Dump AST as serialized string and SVG image - <code>--dump-symtab</code> Dump serialized symbol tables - <code>--dump-types</code> Dump all used types - <code>--dump-cache-stats</code> Dump stats for compiler-internal lookup caches <code>-ir</code> <code>--dump-ir</code> Dump LLVM-IR <code>-s</code>, <code>-asm</code> <code>--dump-assembly</code> Dump Assembly code - <code>--dump-object-file</code> Dump object files - <code>--dump-dependency-graph</code> Dump compile unit dependency graph <code>-j &lt;n&gt;</code> <code>--jobs &lt;n&gt;</code> Set number of jobs to parallelize compilation (default is auto) <code>-O&lt;x&gt;</code> - Set optimization level.  Valid options: <code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>, <code>-Oz</code> <code>-g</code> <code>--debug-info</code> Generate debug info to debug the executable in GDB, etc. - <code>--disable-verifier</code> Disable LLVM module and function verification (only recommended for debugging the compiler) - <code>--ignore-cache</code> Compile always and ignore the compile cache - <code>--use-lifetime-markers</code> Generate lifetime markers to enhance optimizations"},{"location":"cli/uninstall/","title":"Uninstall subcommand","text":"<p>The <code>uninstall</code> subcommand can be used to delete an installed executable again.</p>"},{"location":"cli/uninstall/#usage","title":"Usage","text":"Long formShort form <p>Use the <code>uninstall</code> subcommand by executing: Bash<pre><code>$ spice uninstall [options] &lt;main-source-file&gt;\n</code></pre></p> <p>Use the <code>uninstall</code> subcommand by executing: Bash<pre><code>$ spice u [options] &lt;mail-source-file&gt;\n</code></pre></p>"},{"location":"how-to/cli-parser/","title":"Build a CLI Interface","text":"<p>Spice comes with a batteries-included CLI parser to make it easy to build command line interfaces. The following example shows how to build a simple CLI interface with a few sub-commands and options.</p>"},{"location":"how-to/cli-parser/#minimal-usage","title":"Minimal usage","text":"<p>Here you can see what the minimal configuration for the CLI parser looks like:</p> Spice<pre><code>// app-name.spice\n\nimport \"std/io/cli-parser\";\n\nf&lt;int&gt; main(int argc, string[] argv) {\n    CliParser cli = CliParser(\"app-name\", \"Short description of the app\");\n    return cli.parse(argc, argv);\n}\n</code></pre> <p>These two lines of code provide you with a fully functional CLI parser. The <code>CliParser</code> constructor takes two arguments: - <code>app-name</code>: string - The name of the application. This will be used in the help text. - <code>app-description</code>: string - A short description of the application. This will also be used in the help text.</p> <p>The CLI parser automatically provides two flags, one for printing the help text and one for printing the version info. So if we compile and run this code, we will get the following output:</p> Bash Session<pre><code>$ ./app-name\nShort description of the app\n\nUsage: ./app-name [options]\n\nFlags:\n--help,-h                       Print this help message\n--version,-v                    Print version info\n</code></pre> <p>The default version is <code>v0.0.1</code>.</p>"},{"location":"how-to/cli-parser/#add-flags","title":"Add flags","text":"<p>Now, let's add more information to the help text and add a flag:</p> Spice<pre><code>// app-name.spice\n\nimport \"std/io/cli-parser\";\n\nf&lt;int&gt; main(int argc, string[] argv) {\n    CliParser cli = CliParser(\"app-name\", \"Short description of the app\");\n    cli.setVersion(\"v1.0.0\");\n    cli.setFooter(\"(c) 2024 by John Doe\");\n\n    bool flagValue = false;\n    cli.addFlag(\"--hi\", flagValue, \"Say Hi\");\n\n    cli.parse(argc, argv);\n\n    if flagValue {\n        printf(\"Hi!\\n\");\n    }\n}\n</code></pre> <p>Now we get this help text:</p> Bash Session<pre><code>$ ./app-name\nShort description of the app\n\nUsage: ./app-name [options]\n\nFlags:\n--help,-h                       Print this help message\n--version,-v                    Print version info\n--hi                            Say Hi\n\n(c) 2024 by John Doe\n</code></pre> <p>When we run the program with the <code>--hi</code> flag, we get the following output:</p> Bash Session<pre><code>$ ./app-name --hi\nHi!\n</code></pre>"},{"location":"how-to/cli-parser/#add-subcommands","title":"Add subcommands","text":"<p>To build more advanced CLI interfaces, you can add subcommands. Let's add a <code>greet</code> subcommand to our CLI interface:</p> Spice<pre><code>// app-name.spice\n\nimport \"std/io/cli-parser\";\n\nf&lt;int&gt; main(int argc, string[] argv) {\n    CliParser cli = CliParser(\"app-name\", \"Short description of the app\");\n    cli.setVersion(\"v1.0.0\");\n    cli.setFooter(\"(c) 2024 by John Doe\");\n\n    CliSubcommand&amp; greet = cli.addSubcommand(\"greet\", \"Greet someone\");\n    CliSubcommand&amp; walk = cli.addSubcommand(\"walk\", \"Walk somewhere\");\n\n    cli.parse(argc, argv);\n}\n</code></pre> <p>Each subcommand comes with its own <code>--help</code> flag out of the box, that prints the help text for that specific subcommand. Subcommands can also have their own sub-commands. In other words, they can be nested:</p> Spice<pre><code>// app-name.spice\n\nimport \"std/io/cli-parser\";\n\nf&lt;int&gt; main(int argc, string[] argv) {\n    CliParser cli = CliParser(\"app-name\", \"Short description of the app\");\n    cli.setVersion(\"v1.0.0\");\n    cli.setFooter(\"(c) 2024 by John Doe\");\n\n    CliSubcommand&amp; greet = cli.addSubcommand(\"greet\", \"Greet someone\");\n    CliSubcommand&amp; greetFriendly = greet.addSubcommand(\"friendly\", \"Greet someone in a friendly way\");\n    CliSubcommand&amp; greetFormal = greet.addSubcommand(\"formal\", \"Greet someone in a formal way\");\n    CliSubcommand&amp; walk = cli.addSubcommand(\"walk\", \"Walk somewhere\");\n\n    cli.parse(argc, argv);\n}\n</code></pre>"},{"location":"how-to/oop/","title":"Object-oriented programming","text":"<p>Spice supports object-oriented programming in the form of composition. That means that types can be composed via structs, interfaces and methods.</p>"},{"location":"how-to/oop/#example-scenario","title":"Example scenario","text":"<p>You need to model three different kinds of objects: humans, cars and parrots. Therefore, you create three structs with the respective names:</p> Spice<pre><code>type Human struct {\n    string firstName\n    string lastName\n    unsigned int age\n}\n\ntype Car struct {\n    string brand\n    string model\n    unsigned int seats\n}\n\ntype Parrot struct {\n    string name\n    unsigned int age\n}\n</code></pre> <p>Now, as you have a speaking parrot, you want to give the parrot and the human the ability to speak. In addition to that, all three objects can make sounds. The recommended way of doing this, is to use interfaces like this:</p> Spice<pre><code>type Speak interface {\n    p sayHello(string);\n}\n\ntype MakeSound interface {\n    p makeSound();\n}\n\ntype Human struct : MakeSound, Speak {\n    string firstName\n    string lastName\n    unsigned int age\n}\n\np Human.ctor(string firstName, string lastName, unsigned int age) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.age = age;\n}\n\np Human.makeSound() {\n    printf(\"Sigh...\\n\");\n}\n\np Human.sayHello(string name) {\n    printf(\"Hi, %s!\\n\", name);\n}\n\ntype Car struct : MakeSound {\n    string brand\n    string model\n    unsigned int seats\n}\n\np Car.ctor(string brand, string model, unsigned int seats) {\n    this.brand = brand;\n    this.model = model;\n    this.seats = seats;\n}\n\np Car.makeSound() {\n    printf(\"Wroom, wroom!\\n\");\n}\n\ntype Parrot struct : MakeSound, Speak {\n    string name\n    unsigned int age\n}\n\np Parrot.ctor(string name, unsigned int age) {\n    this.name = name;\n    this.age = age;\n}\n\np Parrot.makeSound() {\n    printf(\"Sqawk!\\n\");\n}\n\np Parrot.sayHello(string name) {\n    printf(\"Hello %s, squawk!\\n\", name);\n}\n\nf&lt;int&gt; main() {\n    Human human = Human(\"John\", \"Doe\", 25);\n    Car car = Car(\"Toyota\", \"Corolla\", 5);\n    Parrot parrot = Parrot(\"Polly\", 3);\n\n    human.makeSound();\n    car.makeSound();\n    parrot.makeSound();\n\n    human.sayHello(\"Jane\");\n    parrot.sayHello(\"Jane\");\n    return 0;\n}\n</code></pre> <p>All living beings, parrots and humans have an age. So you might want to extract the <code>unsigned int age</code>, that exists in both structs to a separate struct called <code>LivingBeing</code>.</p> Spice<pre><code>// ...\n\ntype LivingBeing struct {\n    unsigned int age\n}\n\ntype Human struct : MakeSound, Speak {\n    compose LivingBeing livingBeing\n    string firstName\n    string lastName\n}\n\ntype Parrot struct : MakeSound, Speak {\n    compose LivingBeing livingBeing\n    string name\n}\n\n// ...\n</code></pre> <p>The <code>compose</code> keyword is used to include the fields and methods of another struct into the current struct. The members of the parent struct are accessible directly via name. e.g. <code>parrot.age</code> or through the compose member itself, e.g. <code>parrot.livingBeing.age</code>.</p>"},{"location":"how-to/web-assembly/","title":"Compile for WebAssembly","text":"<p>Due to the fact, that Spice uses LLVM as compiler backbone, it is capable of cross-compiling to many different target architectures which LLVM provides backends for. LLVM also supports compiling to WebAssembly and so does Spice. This guide shows you how to use Spice as programming language underneath your web applications, using WebAssembly.</p>"},{"location":"how-to/web-assembly/#prerequisites","title":"Prerequisites","text":"<p>For WebAssembly compilation and linkage, a WebAssembly linker is required. Spice uses the <code>wasm-link</code> linker, shipped with Clang per default. This means, you need Clang and <code>wasm-link</code> installed on your system. On Linux, you can simply install the Clang package. On Windows you can download MinGW64 with Clang from e.g. winlibs.com.</p>"},{"location":"how-to/web-assembly/#writing-the-program","title":"Writing the program","text":"<p>For the sake of example, we write a recursive fibonacci algorithm in Spice, which we can make accessible to JavaScript.</p> Spice<pre><code>#[core.compiler.mangle = false]\npublic f&lt;int&gt; fibo(int n) {\n    if n &lt;= 1 { return n; }\n    return fibo(n - 1) + fibo(n - 2);\n}\n\n// Main function can be deleted, when compiling with --no-entry\nf&lt;int&gt; main() {\n   int fiboBase = 45;\n   printf(\"Fibonacci of %d: %d\", fiboBase, fibo(fiboBase));\n}\n</code></pre> <p>You can test, if the code works by compiling and running it, using the following command:  <code>$ spice run main.spice</code></p> <p>Spice will not emit the <code>main</code> function when compiling to WebAssembly, so you may delete it now. The important part is to mark all functions as public, which should be accessible from JavaScript later on. Please also note, that you cannot link any external functions from the C standard library into your WebAssembly program, because it is required to be portable to any system. The <code>wasm-link</code> linker will complain if you try to use any external function when trying to compile to <code>wasm32</code> or <code>wasm64</code>.</p>"},{"location":"how-to/web-assembly/#cross-compile-to-wasm32","title":"Cross-compile to wasm32","text":"<p>Now execute the following command to compile the code to an output <code>.wasm</code> file:  <code>$ spice build -O3 --no-entry --target-arch=wasm32 main.spice</code></p> <ul> <li><code>-O3</code> enables the highest possible optimization. You might also want to use <code>-Oz</code> instead to optimize for binary size.</li> <li><code>--no-entry</code> makes Spice not generate code for the <code>main</code> function. This also lifts the requirement for <code>main</code></li> <li><code>--target-arch=wasm32</code> sets the cross-compilation target to WebAssembly. Another valid option is <code>wasm64</code>, which is currently not    fully supported by browser engines as well as LLVM</li> </ul> <p>If you have installed wabt (the WebAssembly binary toolkit), you can view a textual form of your WebAssembly binary like this:  <code>$ wasm-objdump -x main.wasm</code></p>"},{"location":"how-to/web-assembly/#setup-webassembly-project","title":"Setup WebAssembly project","text":"<p>Create an <code>index.html</code> file in the same directory, where the <code>main.wasm</code> file lives with the following contents:</p> HTML<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en-US\"&gt;\n&lt;head&gt;\n    &lt;title&gt;Spice WebAssembly Demo&lt;/title&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Also create an <code>index.js</code> file:</p> JavaScript<pre><code>const fiboBase = 45;\n\nWebAssembly.instantiateStreaming(fetch('main.wasm'))\n  .then((results) =&gt; {\n    // WebAssembly\n    const startWasm = window.performance.now();\n    let result = results.instance.exports.fibo(fiboBase);\n    const stopWasm = window.performance.now();\n    console.log(\"Fibonacci Spice wasm: \" + result);\n    console.log(\"Duration (millis): \" + (stopWasm - startWasm));\n    // JavaScript\n    const startJS = window.performance.now();\n    result = fibo(fiboBase);\n    const stopJS = window.performance.now();\n    console.log(\"Fibonacci JS: \" + result);\n    console.log(\"Duration (millis): \" + (stopJS - startJS));\n  });\n\nfunction fibo(n) {\n  if (n &lt;= 1) { return n; }\n  return fibo(n - 1) + fibo(n - 2);\n}\n</code></pre> <p>As you can see, you can load the <code>main.wasm</code> file in JavaScript using the WebAssembly module. When successful, we can call all exposed (<code>public</code>) Spice functions using their name.</p>"},{"location":"how-to/web-assembly/#execute","title":"Execute","text":"<p>Now you can use e.g. the node <code>http-server</code> to spin up the web project locally: Bash<pre><code>npm i -g http-server\nhttp-server .\n</code></pre></p> <p>Navigate to <code>http://127.0.0.1:8080</code> and open the developer console. After waiting a bit, you should see something like this:</p> Text Only<pre><code>Fibonacci Spice wasm: 1134903170\nDuration (millis): 5346.60000000149\nFibonacci JS: 1134903170\nDuration (millis): 8946.19999999553\n</code></pre> <p>Congrats on your first WebAssembly project in Spice!</p>"},{"location":"install/docker/","title":"Use with Docker","text":""},{"location":"install/docker/#download","title":"Download","text":"<p>You don't have to pull the image first. You also can skip this step.</p> Docker HubGitHub Container Registry Bash<pre><code>docker pull chillibits/spice\n</code></pre> Bash<pre><code>docker pull ghcr.io/spicelang/spice\n</code></pre>"},{"location":"install/docker/#use","title":"Use","text":"Linux - Docker HubLinux - GHCRWindows - Docker HubWindows - GHCR Bash<pre><code>docker run --rm -it -v $(pwd):/spice/out chillibits/spice\n</code></pre> Bash<pre><code>docker run --rm -it -v $(pwd):/spice/out ghcr.io/spicelang/spice\n</code></pre> Bash<pre><code>docker run --rm -it -v ${pwd}:/spice/out chillibits/spice\n</code></pre> Bash<pre><code>docker run --rm -it -v ${pwd}:/spice/out ghcr.io/spicelang/spice\n</code></pre>"},{"location":"install/docker/#customize","title":"Customize","text":""},{"location":"install/docker/#custom-output-path","title":"Custom output path","text":"<p>You can use another output path by replacing <code>$(pwd)</code>/<code>${pwd}</code> with a custom path.</p> <p>Example</p> Bash<pre><code>docker run --rm -it -v ./project:/spice/out chillibits/spice\n</code></pre>"},{"location":"install/linux/","title":"Install on Linux","text":""},{"location":"install/linux/#install-from-repository","title":"Install from repository","text":"Debian/UbuntuFedoraCentOS <p>To install Spice on Debian, execute the following commands in your terminal: Bash<pre><code>sudo apt-get install ca-certificates software-properties-common\ncurl -fsSL https://server.chillibits.com/files/repo/gpg | sudo tee /etc/apt/trusted.gpg.d/chillibits.asc\nsudo add-apt-repository \"deb https://repo.chillibits.com/$(lsb_release -is | awk '{print tolower($0)}')-$(lsb_release -cs) $(lsb_release -cs) main\"\nsudo apt-get install spice\n</code></pre></p> <p>To install Spice on Fedora, execute the following commands in your terminal: Bash<pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf config-manager --add-repo https://server.chillibits.com/files/repo/fedora.repo\nsudo dnf install spice\n</code></pre></p> <p>To install Spice on CentOS, execute the following commands in your terminal: Bash<pre><code>sudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://server.chillibits.com/files/repo/centos.repo\nsudo yum install spice\n</code></pre></p> <p>If you have cloned the Spice repository from GitHub, you can execute the respective <code>install-latest-*.sh</code> script to install Spice from a user's perspective.</p>"},{"location":"install/linux/#install-from-package-file","title":"Install from package file","text":"<p>You can also install Spice from a Linux package.</p> Debian/UbuntuFedora/CentOSAlpine <p>Download amd64 Download arm64</p> <p>To install it, execute the following command: Bash<pre><code>dpkg -i &lt;deb-file-name&gt;\n</code></pre></p> <p>Download amd64 Download arm64</p> <p>To install it, execute the following command: Bash<pre><code>rpm -U &lt;rpm-file-name&gt;\n</code></pre></p> <p>Download amd64 Download arm64</p> <p>To install it, execute the following command: Bash<pre><code>apk add --allow-untrusted &lt;apk-file-name&gt;\n</code></pre></p>"},{"location":"install/linux/#use","title":"Use","text":"Bash<pre><code>spice [options] &lt;input&gt;\n</code></pre>"},{"location":"install/source/","title":"Build or install from source","text":""},{"location":"install/source/#setup","title":"Setup","text":"<p>Before being able to compile the source code, you first have to download it from GitHub. Furthermore you need a common C++ compiler (preferably GCC) and CMake to build the compiler executable.</p>"},{"location":"install/source/#clone-from-github","title":"Clone from GitHub","text":"Bash<pre><code>git clone https://github.com/spicelang/spice.git\ncd spice\n</code></pre>"},{"location":"install/source/#run-setup-script-for-setting-up-your-dev-environment","title":"Run setup script for setting up your dev environment","text":"<p>To build Spice, you can use the <code>dev-setup.sh</code> for Linux or the <code>dev-setup.bat</code> for Windows. This will prepare your dev environment, install the correct LLVM version and builds the Spice executable for the first time to the <code>bin</code> directory.</p> LinuxWindows Bash<pre><code>./dev-setup.sh\n</code></pre> Bash<pre><code>.\\dev-setup.bat\n</code></pre>"},{"location":"install/source/#use","title":"Use","text":"Bash<pre><code>cd bin\nspice [options] &lt;input&gt;\n</code></pre>"},{"location":"install/windows/","title":"Install on Windows","text":""},{"location":"install/windows/#install-via-winget-cli","title":"Install via winget cli","text":"<p>Spice gets distributed for Windows via the new Windows package manager called winget.  In the future, winget will be available for download in the Microsoft Store. Currently, the easiest way to install winget is to download it manually from GitHub. Visit the installation instructions from Microsoft.</p> <p>As soon as the Windows package manager is installed on your Windows machine, you can open up powershell and execute the following installation command:  Bash<pre><code>winget install ChilliBits.Spice\n</code></pre> After installing Spice, you should be able to run it. If not, please restart your powershell instance to make it reload the available commands.</p>"},{"location":"install/windows/#install-manually-via-installer","title":"Install manually via installer","text":"<p>Download 64bit</p> <p>It is possible that you see an error notification by your anti-virus software complaining about Spice being a potentially dangerous application. This can happen if the latest version was released very recently and too few people downloaded it yet. If you want to validate the file signature, you can visit this GitHub repo, select your version and open the file <code>ChilliBits.Spice.installer.yaml</code>. There you can find the SHA256 signatures for the <code>x64</code> exe installer.</p>"},{"location":"install/windows/#use","title":"Use","text":"Bash<pre><code>spice [options] &lt;input&gt;\n</code></pre>"},{"location":"language/aliases/","title":"Type Aliases","text":"<p>Spice supports defining type aliases like this:</p>"},{"location":"language/aliases/#usage","title":"Usage","text":"Spice<pre><code>type I32 alias int;\ntype I64 alias long;\n\ntype T int|long|short;\ntype TestStruct&lt;T&gt; struct {\n    bool f1\n    unsigned T f2\n}\ntype TS alias TestStruct&lt;short&gt;;\n</code></pre>"},{"location":"language/arrays/","title":"Arrays","text":"<p>You can use arrays in Spice for any primitive or custom struct data type.</p>"},{"location":"language/arrays/#usage","title":"Usage","text":"<p>To initialize an <code>array</code> e.g. of type string, you can write: Spice<pre><code>string[3] myStringArray = [ \"First item\", \"Second Item\", \"Third item\" ];\n</code></pre></p> <p>The <code>3</code> in the brackets is the size of the array. The initial values can be provided in curly braces after the assign operator and must be of the same data type.  You can only initialize an array with the number of items equal the arrays size or no items.</p> Type Default value <code>int</code> <code>0</code> <code>double</code> <code>0.0</code> <code>string</code> <code>\"\"</code> <code>bool</code> <code>false</code> <code>struct</code> Instance with default values for all fields <p>To access an array item, you can use the index. The indexes are &gt;= 0 per definition: Spice<pre><code>string item3Value = myStringArray[3];\n</code></pre></p> <p>More complex expressions for initial array values and item indexing are possible. Here's an example: Spice<pre><code>// Initialize array\ndyn condition = 1 != 2;\nbool[3] myBoolArray = [ condition ? true : false, false, true ];\n\n// Access item 0\nint i = 2;\nbool itemValue = myBoolArray[i -= 2];\n\nprintf(\"Value: %u\", itemValue);\n</code></pre></p>"},{"location":"language/attributes/","title":"Attributes","text":"<p>Spice offers the option to annotate single function or whole modules via attributes.</p> <p>Optional value for bool attributes</p> <p>For attributes of type bool, the value <code>true</code> can be omitted.</p>"},{"location":"language/attributes/#module-attributes","title":"Module attributes","text":"Spice<pre><code>// Attribute for the whole module\n#![core.linker.flag = \"-pthread\"]\n\n// ...\n</code></pre>"},{"location":"language/attributes/#available-attributes","title":"Available attributes","text":"<ul> <li><code>core.linker.flag: string (default: \"\")</code>: Append linker flag</li> <li><code>core.linux.linker.flag: string (default: \"\")</code>: Append linker flag for Linux</li> <li><code>core.windows.linker.flag: string (default: \"\")</code>: Append linker flag for Windows</li> <li><code>core.compiler.alwaysKeepOnNameCollision: bool (default: false)</code>: Always keep the symbols of this source files when merging the name registries of multiple source files</li> </ul>"},{"location":"language/attributes/#function-attributes","title":"Function attributes","text":"Spice<pre><code>#[core.compiler.mangleName = false]\nf&lt;int&gt; test(long input) {\n    return input == 0 ? 123 : 456;\n}\n\n// ...\n</code></pre>"},{"location":"language/attributes/#available-attributes_1","title":"Available attributes","text":"<ul> <li><code>core.compiler.mangle: bool (default: true)</code>: Enable/disable name mangling for the annotated function</li> <li><code>core.compiler.mangledName: string</code>: Set the mangled name for the annotated function</li> </ul>"},{"location":"language/attributes/#external-declaration-attributes","title":"External declaration attributes","text":"Spice<pre><code>#[core.compiler.mangleName = false]\next f&lt;heap byte*&gt; malloc(unsigned long);\n\n// ...\n</code></pre>"},{"location":"language/attributes/#available-attributes_2","title":"Available attributes","text":"<ul> <li><code>core.compiler.mangle: bool (default: true)</code>: Enable/disable name mangling for the annotated function</li> <li><code>core.compiler.mangledName: string</code>: Set the mangled name for the annotated function</li> <li><code>core.linker.dll: bool</code>: Enable linkage as dll (only relevant for Windows)</li> <li><code>test: bool</code>: Mark the annotated function as test</li> <li><code>test.name: string</code>: Set the name of the test (only procedures with the <code>test</code> attribute are considered as tests)</li> <li><code>test.skip: bool</code>: Skip the annotated function (only procedures with the <code>test</code> attribute are considered as tests)</li> </ul>"},{"location":"language/attributes/#struct-attributes","title":"Struct attributes","text":"Spice<pre><code>#[core.compiler.alwaysEmitVTable = true]\npublic type A struct {\n    // ...\n}\n</code></pre>"},{"location":"language/attributes/#available-attributes_3","title":"Available attributes","text":"<ul> <li><code>core.compiler.alwaysEmitVTable: bool</code>: Always emit a vtable for the annotated struct</li> <li><code>core.compiler.packed: bool</code>: Pack the annotated struct</li> </ul>"},{"location":"language/attributes/#interface-attributes","title":"Interface attributes","text":"Spice<pre><code>#[core.compiler.fixedTypeId = 230]\npublic type A interface {\n    // ...\n}\n</code></pre>"},{"location":"language/attributes/#available-attributes_4","title":"Available attributes","text":"<ul> <li><code>core.compiler.fixedTypeId: int</code>: Set a fixed type id for the annotated interface. Intended for internal use only.</li> </ul>"},{"location":"language/builtin-types/","title":"Builtin data types","text":"<p>In extension to the primitive data types, Spice offers several builtin data types.</p>"},{"location":"language/builtin-types/#the-string-data-type","title":"The <code>String</code> data type","text":"<p>In opposite to the string primitive type, the <code>String</code> builtin type is mutable and offers several ways to modify the contained value.</p> <p>Tip</p> <p>Use the <code>string</code> primitive type over the <code>String</code> builtin type as much as possible, due to its advantages in runtime performance. The usage of the <code>String</code> builtin type is only recommended, when you need to modify the value of the string at runtime. <code>string</code> values are always immutable.</p>"},{"location":"language/builtin-types/#constructors","title":"Constructors","text":"<p>The <code>String</code> builtin type offers the following constructors:</p> <ul> <li><code>void String()</code>: Initialize empty</li> <li><code>void String(string)</code>: Initialize with a raw <code>string</code> as start value</li> <li><code>void String(char)</code>: Initialize with a single char</li> <li><code>void String(const String&amp;)</code>: Initialize by copying another <code>String</code> (copy constructor) </li> <li><code>void String(int)</code>: Initialize with an initial size</li> <li><code>void String(long)</code>: Initialize with an initial size</li> </ul>"},{"location":"language/builtin-types/#methods","title":"Methods","text":"<p>The <code>String</code> builtin type offers the following methods:</p> <ul> <li><code>void append(string)</code>: Appends a raw string</li> <li><code>void append(const String&amp;)</code>: Appends a string</li> <li><code>void append(char)</code>: Appends a single char</li> <li><code>void insert(unsigned int, string)</code>: Insert a substring at a given position</li> <li><code>void insert(unsigned long, string)</code>: Insert a substring at a given position</li> <li><code>void insert(unsigned int, const String&amp;)</code>: Insert a substring at a given position</li> <li><code>void insert(unsigned long, const String&amp;)</code>: Insert a substring at a given position</li> <li><code>void insert(unsigned int, char)</code>: Insert a character at a given position</li> <li><code>void insert(unsigned long, char)</code>: Insert a character at a given position</li> <li><code>string getRaw()</code>: Returns a char* to the heap allocated value</li> <li><code>unsigned long getLength()</code>: Returns the length of the string in chars</li> <li><code>unsigned long getCapacity()</code>: Returns the allocated space in bytes</li> <li><code>bool isEmpty()</code>: Checks if the string has a length of 0</li> <li><code>bool isFull()</code>: Checks if the length is equal with the capacity</li> <li><code>void clear()</code>: Clear the value of the string</li> <li><code>long find(string, unsigned int)</code>: Returns the index, where a substring was found, starting from a start index</li> <li><code>long find(string, unsigned long)</code>: Returns the index, where a substring was found, starting from a start index</li> <li><code>long find(char, unsigned long)</code>: Returns the index, where a subchar was found, starting from a start index</li> <li><code>long rfind(string, unsigned int)</code>: Returns the index, where a substring was found, starting from reversed at a start index</li> <li><code>long rfind(string, unsigned long)</code>: Returns the index, where a substring was found, starting from reversed at a start index</li> <li><code>long rfind(char, unsigned long)</code>: Returns the index, where a subchar was found, starting from reversed at a start index</li> <li><code>bool contains(string)</code>: Checks if the string contains a substring</li> <li><code>bool startsWith(string)</code>: Checks if the string starts with a substring</li> <li><code>bool endsWith(string)</code>: Checks if the string ends with a substring</li> <li><code>void reverse()</code>: Reverses the value of the string</li> <li><code>void replace(string, string, unsigned long)</code>: Replaces a substring with another string, starting from a start index</li> <li><code>void replaceAll(string, string)</code>: Replaces all occurrences of a substring with another string</li> <li><code>void replaceAll(char, char)</code>: Replaces all occurrences of a subchar with another char</li> <li><code>String getSubstring(unsigned int, long)</code>: Returns the substring from start index <code>x</code> and length <code>y</code></li> <li><code>String getSubstring(unsigned long, long)</code>: Returns the substring from start index <code>x</code> and length <code>y</code></li> <li><code>String getSubstring(unsigned short, long)</code>: Returns the substring from start index <code>x</code> and length <code>y</code></li> <li><code>String trim()</code>: Remove whitespace from the front and back</li> <li><code>void reserve(unsigned int)</code>: Increase the capacity to the given number</li> <li><code>void reserve(unsigned long)</code>: Increase the capacity to the given number</li> <li><code>void reserve(unsigned short)</code>: Increase the capacity to the given number</li> </ul>"},{"location":"language/builtin-types/#static-functions","title":"Static functions","text":"<p>The <code>String</code> builtin type offers the following static functions:</p> <ul> <li><code>getRawLength(string)</code>: Returns the length of a raw string</li> <li><code>isRawEqual(string, string)</code>: Checks if two raw strings are equal in value</li> </ul>"},{"location":"language/builtin-types/#operators","title":"Operators","text":"<p>The <code>String</code> builtin type overrides the following operators:</p> <ul> <li><code>String operator+(const String&amp;, const String&amp;)</code>: Concatenates two strings and returns the result</li> <li><code>String operator+(const String&amp;, const string&amp;)</code>: Concatenates a string and a raw string and returns the result</li> <li><code>String operator+(const String&amp;, const char&amp;)</code>: Concatenates a string and a raw string and returns the result</li> <li><code>String operator+(const string&amp;, const String&amp;)</code>: Concatenates a raw string and a string and returns the result</li> <li><code>String operator+(const string&amp;, const string&amp;)</code>: Concatenates two raw strings and returns the result</li> <li><code>String operator+(const string&amp;, const char&amp;)</code>: Concatenates two raw strings and returns the result</li> <li><code>void operator+=(String&amp;, String)</code>: Appends a string</li> <li><code>void operator+=(String&amp;, string)</code>: Appends a raw string</li> <li><code>void operator+=(String&amp;, char)</code>: Appends a single char</li> <li><code>String operator*(const String&amp;, int)</code>: Concatenates a string with itself n times</li> <li><code>String operator*(const String&amp;, long)</code>: Concatenates a string with itself n times</li> <li><code>String operator*(const String&amp;, short)</code>: Concatenates a string with itself n times</li> <li><code>String operator*(int, const String&amp;)</code>: Concatenates a string with itself n times</li> <li><code>String operator*(long, const String&amp;)</code>: Concatenates a string with itself n times</li> <li><code>String operator*(short, const String&amp;)</code>: Concatenates a string with itself n times</li> <li><code>void operator*=(String&amp;, int)</code>: Concatenates with itself n times</li> <li><code>void operator*=(String&amp;, long)</code>: Concatenates with itself n times</li> <li><code>void operator*=(String&amp;, short)</code>: Concatenates with itself n times</li> <li><code>bool operator==(const String&amp;, const String&amp;)</code>: Checks if two strings are equal in value</li> <li><code>bool operator==(const String&amp;, string)</code>: Checks if two strings are equal in value</li> <li><code>bool operator==(string, const String&amp;)</code>: Checks if two strings are equal in value</li> <li><code>bool operator!=(const String&amp;, const String&amp;)</code>: Checks if two strings are unequal in value</li> <li><code>bool operator!=(const String&amp;, string)</code>: Checks if two strings are unequal in value</li> <li><code>bool operator!=(string, const String&amp;)</code>: Checks if two strings are unequal in value</li> </ul>"},{"location":"language/builtin-types/#the-result-data-type","title":"The <code>Result</code> data type","text":"<p>The <code>Result&lt;T&gt;</code> builtin type is a generic type, which is used to return a value or an error. It is used to handle errors</p>"},{"location":"language/builtin-types/#constructors_1","title":"Constructors","text":"<p>The <code>Result&lt;T&gt;</code> builtin type offers the following constructors:</p> <ul> <li><code>void Result(const T&amp;)</code>: Initialize Result object with a value</li> <li><code>void Result(const Error&amp;)</code>: Initialize Result object with an error</li> </ul>"},{"location":"language/builtin-types/#methods_1","title":"Methods","text":"<p>The <code>Result&lt;T&gt;</code> builtin type offers the following methods:</p> <ul> <li><code>T unwrap()</code>: Returns the value of the Result object. If the Result object contains an error, the program will panic</li> <li><code>Error getErr()</code>: Returns the error of the Result object. If no error is present, an error object with error code 0 is returned.</li> <li><code>bool isOk()</code>: Checks if the Result object contains a value</li> <li><code>bool isErr()</code>: Checks if the Result object contains an error</li> </ul>"},{"location":"language/builtin-types/#static-functions_1","title":"Static functions","text":"<p>The <code>Result&lt;T&gt;</code> builtin type offers the following static functions:</p> <ul> <li><code>Result&lt;T&gt; ok(const T&amp;)</code>: Returns a Result object with a value</li> <li><code>Result&lt;T&gt; err(const Error&amp;)</code>: Returns a Result object with an error</li> <li><code>Result&lt;T&gt; err(int, string)</code>: Returns a Result object with an error, constructed with an error code and an error message</li> <li><code>Result&lt;T&gt; err(string)</code>: Returns a Result object with an error, constructed with an error message</li> </ul>"},{"location":"language/builtin-types/#the-error-data-type","title":"The <code>Error</code> data type","text":"<p>The <code>Error</code> builtin type is used to represent an error. It can be used e.g. in combination with the <code>Result&lt;T&gt;</code> type.</p>"},{"location":"language/builtin-types/#constructors_2","title":"Constructors","text":"<p>The <code>Error</code> builtin type offers the following constructors:</p> <ul> <li><code>void Error()</code>: Initialize an empty error object. This object has an error code of 0 and the error message <code>Runtime error</code></li> <li><code>void Error(int, string)</code>: Initialize an error object with an error code and an error message</li> <li><code>void Error(string)</code>: Initialize an error object with an error message</li> </ul>"},{"location":"language/builtin-types/#methods_2","title":"Methods","text":"<p>The <code>Error</code> builtin type offers the following methods:</p> <ul> <li><code>void print()</code>: Prints the error message to the standard error output</li> <li><code>void toPanic()</code>: Triggers a panic with this error</li> </ul>"},{"location":"language/builtins/","title":"Builtin Functions","text":"<p>Spice offers six builtin functions out of the box. Those can be used anywhere without having to be imported manually and can be used to establish a minimal setup for testing or the like.</p>"},{"location":"language/builtins/#the-printf-builtin","title":"The <code>printf</code> builtin","text":"<p>Printf works the same as the <code>printf</code> function in C and is designed for printing a string to the standard text output (cout).</p>"},{"location":"language/builtins/#signature","title":"Signature","text":"<p><code>int printf(string template, ...args)</code></p> <p><code>template</code>: Template string, which can contain placeholders for values, passed as args to the <code>printf</code> builtin.  <code>args</code>: Arbitrary number of arguments of any type. The particular type and the order of the types have to match the placeholders of the template string.</p> <p>Within the template string you can use control characters like the <code>\\n</code> control character to achieve line breaks. This works on Linux and Windows the same way.</p>"},{"location":"language/builtins/#placeholders","title":"Placeholders","text":"Placeholder Type Output Example <code>%c</code> <code>char</code> Character a <code>%d</code>/<code>%i</code> <code>int</code>, <code>short</code>, <code>long</code> Signed decimal integer 392 <code>%u</code> <code>int</code>, <code>short</code>, <code>long</code> Unsigned decimal integer 7235 <code>%o</code> <code>int</code>, <code>short</code>, <code>long</code> Unsigned octal 610 <code>%x</code> <code>int</code>, <code>short</code>, <code>long</code> Unsigned hexadecimal integer 7fa <code>%X</code> <code>int</code>, <code>short</code>, <code>long</code> Unsigned hexadecimal integer (uppercase) 7FA <code>%lld</code> <code>int</code>, <code>short</code>, <code>long</code> Signed decimal long integer 7235 <code>%llu</code> <code>int</code>, <code>short</code>, <code>long</code> Unsigned decimal long integer 392 <code>%a</code> <code>double</code> Hexadecimal floating point (lowercase) -0xc.90fep-2 <code>%A</code> <code>double</code> Hexadecimal floating point (uppercase) -0XC.90FEP-2 <code>%f</code> <code>double</code> Decimal floating point (lowercase) 392.65 <code>%F</code> <code>double</code> Decimal floating point (uppercase) 392.65 <code>%e</code> <code>double</code> Scientific notation (lowercase) 3.9265e+2 <code>%E</code> <code>double</code> Scientific notation (uppercase) 3.9265E+2 <code>%g</code> <code>double</code> Use the shortest representation: <code>%e</code> or <code>%f</code> 392.65 <code>%G</code> <code>double</code> Use the shortest representation: <code>%e</code> or <code>%f</code> 392.65 <code>%s</code> <code>string</code>, <code>char*</code>, <code>char[]</code> String of characters sample <code>%p</code> <code>&lt;any&gt;*</code> Pointer address b8000000 <code>%%</code> - Escape character for printing a single <code>%</code> %"},{"location":"language/builtins/#usage-example","title":"Usage example","text":"Spice<pre><code>printf(\"Here is a string: %s.\\nAnd here is a double: %f\", \"Demo\", 1.123);\n</code></pre>"},{"location":"language/builtins/#the-sizeof-builtin","title":"The <code>sizeof</code> builtin","text":"<p>Sizeof returns the internal size of a variable, constant or type in bytes. To get the size in bits, simply multiply the result by 8.</p>"},{"location":"language/builtins/#signature_1","title":"Signature","text":"<p><code>unsigned long sizeof(&lt;any variable or constant&gt;)</code> or <code>unsigned long sizeof&lt;any type&gt;()</code></p> <p><code>any variable</code>: Variable or constant of any type, <code>any type</code>: Any data type</p>"},{"location":"language/builtins/#usage-example_1","title":"Usage example","text":"Spice<pre><code>sizeof(12); // 4\nsizeof&lt;int&gt;() // 4\n\nint[9] intArray = [];\nsizeof(intArray); // 9 * 4 = 36\n\nsizeof(\"Hello World!\"); // 8 (Strings are Char pointers internally)\n</code></pre>"},{"location":"language/builtins/#the-alignof-builtin","title":"The <code>alignof</code> builtin","text":"<p>Alignof returns the alignment of a variable, constant or type in bytes. To get the alignment in bits, simply multiply the result by 8.</p>"},{"location":"language/builtins/#signature_2","title":"Signature","text":"<p><code>unsigned long alignof(&lt;any variable or constant&gt;)</code> or <code>unsigned long alignof&lt;any type&gt;()</code></p> <p><code>any variable</code>: Variable or constant of any type, <code>any type</code>: Any data type</p>"},{"location":"language/builtins/#usage-example_2","title":"Usage example","text":"Spice<pre><code>alignof(12); // 4\nalignof&lt;int&gt;() // 4\n\nDemoStruct s = DemoStruct{123, 56l, 12s, \"String\"};\nalignof(s); // 8 (the long value is the widest type in the struct)\n\nalignof(\"Hello World!\"); // 8 (Strings are Char pointers internally)\n</code></pre>"},{"location":"language/builtins/#the-typeid-builtin","title":"The <code>typeid</code> builtin","text":"<p>Typeid returns the type id of a variable, constant or type as unsigned long. The type id is not guaranteed to be the same on each program run, but it is guaranteed to be the same for the same type within the same program run.</p>"},{"location":"language/builtins/#signature_3","title":"Signature","text":"<p><code>unsigned long typeid(&lt;any variable or constant&gt;)</code> or <code>unsigned long typeid&lt;any type&gt;()</code></p> <p><code>any variable</code>: Variable or constant of any type, <code>any type</code>: Any data type</p>"},{"location":"language/builtins/#usage-example_3","title":"Usage example","text":"Spice<pre><code>typeid(12); // 1015829715\ntypeid&lt;int&gt;() // 1015829715\n\nDemoStruct s = DemoStruct{123, 56l, 12s, \"String\"};\ntypeid(s); // 1502876624\ntypeid&lt;DemoStruct&gt;(); // 1502876624\n</code></pre>"},{"location":"language/builtins/#the-len-builtin","title":"The <code>len</code> builtin","text":"<p>Len returns the length of a Spice array in items.</p>"},{"location":"language/builtins/#signature_4","title":"Signature","text":"<p><code>int len(dyn[] variable)</code></p> <p><code>variable</code>: Variable of any  array type.</p>"},{"location":"language/builtins/#usage-example_4","title":"Usage example","text":"Spice<pre><code>len([1, 2, 3, 4]); // 4\n\nstring[5] stringArray = [\"string1\", \"string2\", \"string3\"];\nlen(stringArray); // 5\n</code></pre>"},{"location":"language/builtins/#the-panic-builtin","title":"The <code>panic</code> builtin","text":"<p>Panic is used to terminate the program with an error message. The error message will be printed to standard error (stderr) and the program will terminate with exit code <code>1</code>.</p>"},{"location":"language/builtins/#signature_5","title":"Signature","text":"<p><code>void panic(const Error&amp; error)</code></p> <p><code>error</code>: Error object containing the error code and message.</p>"},{"location":"language/builtins/#usage-example_5","title":"Usage example","text":"Spice<pre><code>panic(Error(\"This is an error message\")));\n</code></pre>"},{"location":"language/builtins/#the-syscall-builtin","title":"The <code>syscall</code> builtin","text":"<p>Syscall is used to send a specific syscall to the underlying operating system. Up to six arguments in addition to the syscall number are allowed.</p>"},{"location":"language/builtins/#signature_6","title":"Signature","text":"<p><code>long syscall(unsigned short syscallNumber, ...args)</code></p> <p><code>syscallNumber</code>: Number of the syscall. See here for all Linux syscalls.</p>"},{"location":"language/builtins/#usage-example_6","title":"Usage example","text":"Spice<pre><code>// Use write syscall to print \"Hello World!\"\nconst string str = \"Hello World!\";\nsyscall(/* syscall no = write */ 1s, /*fd = stdout*/ 1, /* buffer */ str, len(str));\n</code></pre> <p>Warning</p> <p>It is not recommended to use the syscall builtin directly. There is a std package for interacting with the OS via system calls. Please use <code>import \"std/os/syscall\";</code> instead.</p>"},{"location":"language/casts/","title":"Type Casts","text":"<p>Sometimes it is useful to directly cast a type to another one. Spice offers type casting for some type combinations. Additionally, the casting operator can always be applied when the source type matches the cast destination type.</p>"},{"location":"language/casts/#usage","title":"Usage","text":"<p>Casting an int to the short data type: Spice<pre><code>int intVar = 12;\nshort shortVar = cast&lt;short&gt;(intVar);\n</code></pre></p> <p>Example for casting for a function call: Spice<pre><code>p testProc(char c, long l) {\n    printf(\"Char was: %c, long was: %d\", c, l);\n}\n\nf&lt;int&gt; main() {\n    int i = 1234567;\n    short s = 65s;\n    testProc(cast&lt;char&gt;(s), cast&lt;long&gt;(i));\n}\n</code></pre></p>"},{"location":"language/constructors-destructors/","title":"Constructors and destructors","text":"<p>Sometimes you want to initialize the field of a struct or execute some action right after creating an instance of it. Spice enables you doing that, by supporting constructors. To clean up a struct instance, destructors can be used.</p>"},{"location":"language/constructors-destructors/#constructors","title":"Constructors","text":"<p>Whenever you create a struct instance like this, Spice will automatically call the <code>ctor</code> method of this struct:</p> Spice<pre><code>type ExampleStruct struct {\n    string message\n    bool showMessage\n}\n\np ExampleStruct.ctor() {\n    this.message = \"Hello world!\";\n    showMessage = false;\n}\n\nf&lt;int&gt; main() {\n    // Note the parentheses instead of the braces of a normal struct instantiation\n    ExampleStruct es = ExampleStruct();\n    // Do something with 'es' ...\n}\n</code></pre> <p>Constructors can also have arguments to pass some information from the caller to the constructor of the struct:</p> Spice<pre><code>// Struct definition ...\n\np ExampleStruct.ctor(string msg = \"Hello World!\") {\n    this.message = msg;\n    showMessage = false;\n}\n\nf&lt;int&gt; main() {\n    ExampleStruct es = ExampleStruct(\"Hi fellow programmers!\");\n    // Do something with 'es' ...\n}\n</code></pre> <p>The <code>ctor</code> method can also be called manually like calling other methods.</p>"},{"location":"language/constructors-destructors/#destructors","title":"Destructors","text":"<p>You have the option to create a destructor by providing a <code>dtor</code> method on a struct. It does not allow any arguments and has no return type, since it is a procedure. Destructors can be especially useful for de-allocating objects in heap memory, that were allocated via <code>malloc()</code>. Whenever a struct variable goes out of scope somewhere in the program, the compiler searches for a destructor and calls it if available.</p> <p>Here is an example for a custom destructor:</p> Spice<pre><code>// Declarations of the generic type T as well as malloc() and free() ...\n\ntype ExampleStruct&lt;T&gt; struct {\n    string message\n    T* messageObject\n}\n\np ExampleStruct.dtor() {\n    free(this.messageObject);\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/","title":"Declaration qualifiers","text":""},{"location":"language/declaration-qualifiers/#the-public-qualifier","title":"The <code>public</code> qualifier","text":"<p>All structures in Spice, that are accessible from outside the module (like functions, procedures, structs, etc.), have private visibility per default. That means that they can't be accessed from outside the module from a source file, that imported the file, where the structures live. If you need to access e.g. a struct from outside the module, you need to attach the qualifier <code>public</code> to it.</p>"},{"location":"language/declaration-qualifiers/#applicable-for","title":"Applicable for","text":"<ul> <li>Functions</li> <li>Procedures</li> <li>Global variables</li> <li>Structs</li> <li>Struct fields</li> <li>Enums</li> <li>Interfaces</li> <li>Interface signatures</li> </ul>"},{"location":"language/declaration-qualifiers/#example","title":"Example","text":"<p>Source file a (<code>a.spice</code>):</p> Spice<pre><code>public p visibleProcedure() {\n    printf(\"Hello World!\");\n}\n</code></pre> <p>Source file b (<code>b.spice</code>):</p> Spice<pre><code>import \"a\" as a;\n\nf&lt;int&gt; main() {\n    a.visibleProcedure(); // This only works if the procedure 'visibleProcedure' is public\n}\n</code></pre> <p>By having private visibility per default, Spice encourages the programmer to adhere to the information hiding principle and expose only the things, that need to be exposed to other modules.</p>"},{"location":"language/declaration-qualifiers/#the-inline-qualifier","title":"The <code>inline</code> qualifier","text":"<p>The <code>inline</code> qualifier can be used for functions and procedures to mark them as inlineable for the compiler explicitly. By marking a function or procedure as inlineable, the compiler is forced to always inline it.</p> <p>Note</p> <p>Marking private functions/procedures with the <code>inline</code> keyword is not necessary in most of the cases, because the compiler inlines smaller, private scoped functions automatically when compiling with an optimization level &gt;= O1.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_1","title":"Applicable for","text":"<ul> <li>Functions</li> <li>Procedures</li> </ul>"},{"location":"language/declaration-qualifiers/#example_1","title":"Example","text":"Spice<pre><code>inline p printHelloWorld() {\n    printf(\"Hello World!\");\n}\n\nf&lt;int&gt; main() {\n    printHelloWorld();\n}\n</code></pre> <p>corresponds to:</p> Spice<pre><code>f&lt;int&gt; main() {\n    printf(\"Hello World!\");\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/#the-const-qualifier","title":"The <code>const</code> qualifier","text":"<p>This qualifier can be used to make variables immutable after the first assignment.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_2","title":"Applicable for","text":"<ul> <li>Local variables</li> <li>Global variables</li> <li>Functions</li> <li>Procedures</li> </ul>"},{"location":"language/declaration-qualifiers/#example_2","title":"Example","text":"Spice<pre><code>const int THIS_IS_A_CONSTANT = 101;\n\nf&lt;int&gt; main() {\n    THIS_IS_A_CONSTANT++; // Will give a compiler error\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/#the-signed-qualifier","title":"The <code>signed</code> qualifier","text":"<p>Marks a numeric variable to use signed numbers explicitly.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_3","title":"Applicable for","text":"<ul> <li>Local variables</li> <li>Global variables</li> <li>Struct fields</li> </ul>"},{"location":"language/declaration-qualifiers/#example_3","title":"Example","text":"Spice<pre><code>f&lt;int&gt; main() {\n    signed int signedInt = -0x567;\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/#the-unsigned-qualifier","title":"The <code>unsigned</code> qualifier","text":"<p>Marks a numeric variable to use unsigned numbers explicitly.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_4","title":"Applicable for","text":"<ul> <li>Local variables</li> <li>Global variables</li> <li>Struct fields</li> </ul>"},{"location":"language/declaration-qualifiers/#example_4","title":"Example","text":"Spice<pre><code>f&lt;int&gt; main() {\n    unsigned int unsignedInt = -0x567; // Will wrap around\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/#the-heap-qualifier","title":"The <code>heap</code> qualifier","text":"<p>Marks a variable to be allocated on the heap. The compiler will generate code to free the memory of the variable, when it goes out of scope. For structs, the compiler will generate code to free all fields, that are marked with the <code>heap</code> keyword, in the dtor.</p> <p>Note: The <code>heap</code> qualifier only works for pointer types. This is enforced by the compiler.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_5","title":"Applicable for","text":"<ul> <li>Local variables</li> <li>Struct fields</li> </ul>"},{"location":"language/declaration-qualifiers/#example_5","title":"Example","text":"Spice<pre><code>type TestStruct struct {\n    heap int* ptr\n}\n</code></pre>"},{"location":"language/declaration-qualifiers/#the-compose-qualifier","title":"The <code>compose</code> qualifier","text":"<p>Includes a struct info the current strut. This is useful for composing structs from other structs.</p> <p>Note: The <code>compose</code> qualifier only works for by-value struct types. This is enforced by the compiler.</p>"},{"location":"language/declaration-qualifiers/#applicable-for_6","title":"Applicable for","text":"<ul> <li>Struct fields</li> </ul>"},{"location":"language/declaration-qualifiers/#example_6","title":"Example","text":"Spice<pre><code>type A struct {\n    int f1\n}\n\ntype B struct {\n    compose A a\n    int f2\n}\n</code></pre>"},{"location":"language/do-while-loops/","title":"Do-While Loops","text":"<p>Do-While loops are designed to do something until a certain condition evaluates to <code>false</code>, but at least execute the action once. This means, that a do-while loop could also run infinitely when the condition never gets fulfilled.  Like the if statement, the condition of the <code>do-while</code> loop must evaluate to a boolean value, but can hold complex, nested expressions.</p>"},{"location":"language/do-while-loops/#usage","title":"Usage","text":"<p>Here is an example of a simple <code>do-while</code> loop: Spice<pre><code>int counter = 0;\ndo {\n    printf(\"Loop run %d\", counter);\n    counter++;\n} while counter &lt; 20;\n</code></pre></p> <p>Optional parentheses</p> <p>As with the if statement, for loop and foreach loop, the parentheses around the head of the <code>do-while</code> loop are optional.</p> <p>If you wanted to intentionally achieve an endless loop, you would write something like this: Spice<pre><code>do {\n    printf(\"This is gonna run forever ...\");\n} while true;\n</code></pre></p> <p>Usage of loop alternatives</p> <p>If you somehow know how many times you want to execute something, we recommend you to use a for loop instead. If you want to iterate over a container of items, consider using the foreach loop.</p>"},{"location":"language/enums/","title":"Enumerations","text":"<p>Spice supports simple enumerations. These constructs are syntactic sugar over <code>int</code> constants.</p>"},{"location":"language/enums/#usage","title":"Usage","text":"<p>Enumerations in Spice work like this:</p> Spice<pre><code>type Fruit enum {\n    APPLE,\n    BANANA,\n    MANGO,\n    ORANGE\n}\n\nf&lt;int&gt; main() {\n    printf(\"Test: %d\", Fruit::MANGO);\n}\n</code></pre> <p>They can be defined only in the global scope. Spice will assign the unsigned integer values 0 to 3 to the items automatically.</p> <p>Enum items can have values assigned to them. Here is an example:</p> Spice<pre><code>type Vegetable enum {\n    CUCUMBER = 5,\n    TOMATO,\n    CARROT = 2,\n    POTATO\n}\n</code></pre> <p>Spice will then assign 0 for <code>TOMATO</code> and 1 for <code>POTATO</code>.</p>"},{"location":"language/for-loops/","title":"For Loops","text":"<p>For loops are designed to execute a block of code n times. That means that you can specify a variable, set an initial value to it and mutate this variable after each loop run, until a certain condition is met. For loops can not only work with integer counters.</p>"},{"location":"language/for-loops/#usage","title":"Usage","text":"<p>Here is an example of a simple <code>for</code> loop: Spice<pre><code>for int i = 1; i &lt;= 10; i++ {\n    printf(\"Round %d\\n\", i);\n}\n</code></pre></p> <p>Optional parentheses</p> <p>As with the if statement, foreach loop and while loop, the parentheses around the head of the <code>for</code> loop are optional.</p> <p>Usage of loop alternatives</p> <p>For loops should only be used when it is foreseeable how often a block of code will run. If this is not the case, it is recommended to use the while loop or do-while loop instead. If you want to iterate over a container of items, consider using the foreach loop.</p>"},{"location":"language/foreach-loops/","title":"Foreach Loops","text":"<p>Foreach loops can be used to iterate over containers, that offer iterator implementations like <code>Vector</code>, <code>ArrayList</code>, etc. as well as arrays of arbitrary elements and number ranges.</p>"},{"location":"language/foreach-loops/#usage","title":"Usage","text":"<p>You can write <code>foreach</code> loops in two different ways:</p>"},{"location":"language/foreach-loops/#ordinary","title":"Ordinary","text":"<p>If you only need the item to work with, the recommended way is to use the ordinary <code>foreach</code> loop:</p> Spice<pre><code>int[7] myIntArray = [ 1, 5, 4, 0, 12, 12345, 9 ];\nforeach (const int item : myIntArray) {\n    printf(\"Item: %d\", item);\n}\n</code></pre> <p>Optional parentheses</p> <p>As with the if statement, for loop and while loop, the parentheses around the head of the <code>foreach</code> loop are optional.</p>"},{"location":"language/foreach-loops/#indexed","title":"Indexed","text":"<p>As soon as you need to access the index of the current item as well, you can use the indexed <code>foreach</code> loop:</p> Spice<pre><code>dyn welcomeMessage = Vector&lt;string&gt;();\nwelcomeMessage.pushBack(\"Hello\");\nwelcomeMessage.pushBack(\"fellow\");\nwelcomeMessage.pushBack(\"Spice\");\nwelcomeMessage.pushBack(\"programmers!\");\nforeach long idx, string word : welcomeMessage {\n    printf(\"Word no. %d: %s\\n\", idx, word);\n}\n</code></pre> <p>Usage of loop alternatives</p> <p>Foreach loops should only be used when you have a container data structure and want to iterate over its items. If this is not the case, we recommend using the for loop, while loop or do-while loop instead.</p>"},{"location":"language/functions/","title":"Functions","text":"<p>Spice distinguishes strictly between functions and procedures. Functions are used to return something, that was calculated from a given input. Other than procedures, functions must have a return value. The paradigm here is, that a function calculates and returns something whereas a procedure executes some action without a result.</p>"},{"location":"language/functions/#usage","title":"Usage","text":"<p>Functions in Spice can be defined like this: Spice<pre><code>f&lt;double&gt; functionName() {\n    ... // Do something\n    return 5.6; // Return some value anywhere in the function body\n}\n</code></pre></p> <p>Spice also allows you to pass arguments to a function. This arguments may also have default values, which can then be omitted when calling the function. </p> <p>Note</p> <p>Optional arguments have to go after the mandatory arguments in the function head.</p>"},{"location":"language/functions/#example-with-default-parameter-value","title":"Example with default parameter value","text":"<p>Here, the second argument is one with a default value attached. Spice<pre><code>f&lt;int&gt; demoFunction(string arg1, double arg2 = 5.89) {\n    ... // Do something with the arguments\n    result = -4;\n}\n</code></pre></p> <p>This function could get called like so: Spice<pre><code>int result1 = demoFunction(\"input\");\nint result1 = demoFunction(\"another input\", 1.0);\n</code></pre></p> <p>Tip</p> <p>If you only want to execute some actions and don't need to return a value to the caller, please consider to use procedures instead of functions.</p>"},{"location":"language/generics/","title":"Generics","text":"<p>Spice offers basic support for generics. Structs and Interfaces as well as functions and procedures can be marked as generic by attaching a template list with one or more generic types to it.</p> <p>Spice resolves the substantiations of generic types at compile time. This helps to keep the runtime performance up. Generic function substantiations that are unused, are removed by the compiler automatically.</p>"},{"location":"language/generics/#generic-types","title":"Generic types","text":"<p>Before using generic types, you have to declare the types first. This can be done like this:</p> Spice<pre><code>type T dyn;\ntype U int|double|long;\n</code></pre> <p>In the above example <code>T</code> can substantiate to an arbitrary type, whilst <code>U</code> can only become an <code>int</code>, a <code>double</code> or a <code>long</code>.</p>"},{"location":"language/generics/#generic-functions-or-procedures","title":"Generic functions or procedures","text":"<p>Here is an example function:</p> Spice<pre><code>f&lt;double&gt; genericFunction&lt;T, U&gt;(T arg1, U arg2, int arg3 = 10) {\n    return arg1 + arg2 + arg3;\n}\n</code></pre> <p>To be able to use generic types in the argument list, the return type or in the function/procedure body, they have to be included in the template list, that is attached at the function (in the above example <code>&lt;T, U&gt;</code>). If this is not the case, the compiler will ask you to do so.</p> <p>As mentioned above, the substantiations of generic types are collected at compile time. That means, that the compiler is able to type-check all concrete substantiations to ensure that e.g. operators are compatible with the concrete types. Furthermore, this enables more optimizations and does not require to carry runtime type information at runtime, which improves runtime speed.</p>"},{"location":"language/generics/#generic-structs","title":"Generic structs","text":"<p>Here is a generic struct example:</p> Spice<pre><code>type T bool|short|long;\n\ntype Vector&lt;T&gt; struct {\n    T* contents\n    int cap\n}\n\np Vector.print() {\n    printf(\"Ptr: %p\", this.contents);\n}\n</code></pre> <p>The above example shows, that you can use the generic type as part of struct field types. Like normal structs, generic structs can also have methods. The concrete types for the generic types, used for the parent struct, are inherited by the method, so you do not have to define the method above with following signature: <code>Vector&lt;T&gt;.print()</code>.</p>"},{"location":"language/hello-world/","title":"Hello World","text":""},{"location":"language/hello-world/#introduction","title":"Introduction","text":"<p>In this example, we will code a simple \"Hello World\" program in Spice. What it does is to simply print \"Hello World!\" to the console when it gets started. The guide assumes, that you already have Spice installed on your development system and are ready to go.</p>"},{"location":"language/hello-world/#write-your-first-program","title":"Write your first program","text":"<p>The first thing you need is a new file to hold the Spice code for your program. Please create a new file in an arbitrary directory and call it <code>hello-world.spice</code>. Open up the file in a text editor of your choice and paste following code in it:</p> Spice<pre><code>f&lt;int&gt; main() {\n    printf(\"Hello World!\");\n}\n</code></pre>"},{"location":"language/hello-world/#run-your-first-program","title":"Run your first program","text":"<p>Save the file and open a terminal in the directory, where the <code>hello-world.spice</code> file lives. Then run the following command: <code>spice run hello-world.spice</code>.</p> <p>This is what you should see: Bash<pre><code>$ spice run hello-world.spice\nHello World!\n</code></pre></p> <p>Congratulations! You just wrote and executed your first Spice program!</p> <p>You can follow the next pages to see, what else Spice can do for you. Feel free to skip to sections of interest to you.</p>"},{"location":"language/if-statements/","title":"If Statements","text":"<p>If statements can be used to execute parts of the program only if a condition is <code>true</code>. The specialist term for this is \"branching\".  The condition of <code>if</code> statements can consist of more complex expressions, but always have to evaluate to a bool data type.</p>"},{"location":"language/if-statements/#usage","title":"Usage","text":"<p>Here's a simple example for an <code>if</code> statement: Spice<pre><code>int counter = 1;\nif counter &lt;= 10 {\n    counter += 3;\n}\n</code></pre> The block between the curly braces only gets executed when the variable <code>counter</code> is less or equal 10.</p> <p>Optional parentheses</p> <p>As with the for, foreach and while loops, the parentheses around the head of the <code>if</code> statement are optional.</p> <p>Let's take a look at a more complex condition: Spice<pre><code>dyn counter = 1;\nbool otherCondition = false;\nif (otherCondition ? counter : 5) != 1 {\n    counter--;\n}\n</code></pre></p> <p>This piece of code is a bit pointless, but you can see, that you can also have more complex conditions in there.</p>"},{"location":"language/interfaces/","title":"Interfaces","text":"<p>Description ...</p>"},{"location":"language/interfaces/#usage","title":"Usage","text":"<p>ToDo ...</p>"},{"location":"language/lambda-functions/","title":"Lambda functions","text":"<p>Spice allows you to create lambda functions. Lambda functions are anonymous functions that can be used as values. They are useful for e.g. passing callback functions as parameters into other functions.</p>"},{"location":"language/lambda-functions/#usage","title":"Usage","text":"<p>Lambdas in Spice work like this:</p>"},{"location":"language/lambda-functions/#procedure-lambdas","title":"Procedure lambdas","text":"Spice<pre><code>// Definition\np(int, double) lambda = p(int a, double b) {\n    printf(\"Lambda was called with %d and %f\", a, b);\n};\n// Call\nlambda(5, 3.14);\n</code></pre>"},{"location":"language/lambda-functions/#function-lambdas","title":"Function lambdas","text":"Spice<pre><code>// Definition\nf&lt;int&gt;(const String&amp;, bool) lambda = f&lt;int&gt;(const String&amp; str, bool b) {\n    if (b) {\n        return str.getLength();\n    } else {\n        return -1;\n    }\n};\n// Call\nint result = lambda(String(\"Hello\"), true);\n</code></pre>"},{"location":"language/lambda-functions/#inline-lambdas","title":"Inline lambdas","text":"Spice<pre><code>sort((int x, int y) =&gt; x &lt; y);\n</code></pre>"},{"location":"language/main-function/","title":"Main Function","text":"<p>The <code>main</code> function is the entry point to any Spice program. When the operating system runs your compiled executable, the <code>main</code> function is called. Therefore, it is mandatory and must have the signature <code>int main()</code> or <code>int main(int argc, string[] argv)</code> for retrieving command line arguments. The main function has a return value of type <code>int</code>, which represents the return / exit / status code of the executable.</p>"},{"location":"language/main-function/#usage","title":"Usage","text":"<p>The <code>main</code> function can be declared like this: Spice<pre><code>f&lt;int&gt; main() {\n    // Do something ...\n}\n</code></pre></p> <p>Like any other function, the <code>main</code> function automatically declares the variable <code>result</code> of the same type as the function return type, which is <code>int</code> in this case. You then have the option to use either the return statement (e.g.: <code>return 1;</code>) or assign a value to the <code>result</code> variable. If you choose the second option, the function continues to run and return the assigned value at the end of the function body. Unlike normal functions, the <code>main</code> function has <code>0</code> as the initial value assigned to the <code>result</code> variable for reasons of convenience and to not always have to write <code>return 0;</code> or <code>result = 0;</code> to exit the program with a positive exit code.</p> <p>Hello World program</p> <p>Now, as you know how to start a program in Spice, you may like to write your first Spice program. Visit the guide for the Hello World example to get started!</p>"},{"location":"language/main-function/#command-line-arguments","title":"Command Line Arguments","text":"<p>Spice programs can accept command line arguments similar you would write it in C:</p> Spice<pre><code>f&lt;int&gt; main(int argc, string[] argv) {\n    printf(\"Number of arguments: %d\\n\", argc);\n    printf(\"Argument no. 0: %s\\n\", argv[0]);\n    if (argc &gt; 1) {\n        printf(\"Argument no. 1: %s\\n\", argv[1]);\n    }\n}\n</code></pre> <p>The parameter <code>argc</code> holds the number of passed arguments and the <code>argv</code> array contains the values of those arguments.</p> <p>--no-entry</p> <p>If the <code>--no-entry</code> flag is passed to the Spice compiler, the main function will not be included in the final output binary. Also, if provided, this option makes the main function non-mandatory.</p>"},{"location":"language/methods/","title":"Methods","text":"<p>Methods in Spice basically are functions / procedures, assigned to a struct. Within methods, fields of the parent struct can be accessed like this: <code>this.fieldName</code>.</p>"},{"location":"language/methods/#usage","title":"Usage","text":"<p>A basic setup with one struct field, as well es a getter and a setter could look like this: Spice<pre><code>type Letter struct {\n    string content\n}\n\nf&lt;string&gt; Letter.getContent() {\n    return this.content;\n}\n\np Letter.setContent(string text) {\n    this.content = text;\n}\n\nf&lt;int&gt; main() {\n    dyn letter = Letter { \"No content\" };\n    letter.setContent(\"Hello World!\");\n    printf(\"Content: %s\", letter.getContent());\n}\n</code></pre></p> <p>Output: Text Only<pre><code>Content: Hello World!\n</code></pre></p> <p>Tip</p> <p>You can initialize or destroy structs by using constructors and destructors. Read more about those in the respective documentation section.</p>"},{"location":"language/modules/","title":"Modules","text":"<p>Spice supports the linkage of several source files to one executable. To do so, you can use the <code>import</code> statement for tying in another source file to the current one.</p>"},{"location":"language/modules/#importing-own-source-files","title":"Importing own source files","text":"<p>Here is an example for importing an own source file into the main source file. Imagine you have the <code>utils.spice</code> file, containing some util functions, which you want to use in your main source file <code>main.spice</code>.</p> <p>Util functions file <code>utils.spice</code>: Spice<pre><code>// Simple recursive fibonacci algorithm\npublic f&lt;int&gt; fib(int n) {\n    if n &lt;= 2 { return 1; }\n    return fib(n - 1) + fib(n - 2);\n}\n</code></pre></p> <p>Main source file <code>main.spice</code>: Spice<pre><code>import \"utils\" as fibonacci;\n\nf&lt;int&gt; main() {\n    dyn fibResult = fibonacci::fib(30);\n    printf(\"Fibonacci result: %d\", fibResult);\n}\n</code></pre></p> <p>In the example above, the imported file lives in the same directory as the main source file. If you have a nested folder structure you can state the import like this: <code>import \"sub-folder/sub-sub-folder/utils\" as fibonacci</code>.</p> <p>You can also write the source file like this, using anonymous imports:</p> Spice<pre><code>import \"utils\";\n\nf&lt;int&gt; main() {\n    dyn fibResult = fib(30);\n    printf(\"Fibonacci result: %d\", fibResult);\n}\n</code></pre> <p>In the case that two imported source files expose symbols with the same name, Spice does not offer the anonymous usage of both symbols to prevent the usage of the wrong symbol. Then, you need to specify explicitly, which of the two symbols is meant.</p> <p>Linking against source files with another main function</p> <p>Spice supports linking against source files which include a main function. Although the main function in the imported source file will be ignored and only the main function in the main source file will be taken into account.</p>"},{"location":"language/modules/#importing-functionality-from-the-standard-library","title":"Importing functionality from the standard library","text":"<p>Every import starting with <code>std/</code>, will be automatically assigned to the standard library.</p> Spice<pre><code>import \"std/text/print\";\n\nf&lt;int&gt; main() {\n    println(\"This is a single line\");\n}\n</code></pre>"},{"location":"language/modules/#platform-dependent-imports","title":"Platform dependent imports","text":"<p>If you have written code, that only works on one particular platform (e.g. two function with the same functionality, one for Linux and one for Windows), you can name source files with the suffix of the OS e.g. <code>example_linux.spice</code> / <code>example_windows.spice</code>. Then you can import the files without the suffix: <code>import \"example\" as example;</code>. Depending on your target triple, the matching source file will be chosen at compile time automatically.</p>"},{"location":"language/number-formats/","title":"Number formats","text":"<p>Spice supports four different number formats to cover as many use-cases as possible.</p>"},{"location":"language/number-formats/#decimal-format-base-10","title":"Decimal format (base 10)","text":"<p>Decimal numbers can be written in two ways in Spice. The implicit way:</p> Spice<pre><code>int i32 = 123;\nshort i16 = 123s;\nlong i64 = 123l;\n</code></pre> <p>or the explicit way:</p> Spice<pre><code>int i32 = 0d123;\nshort i16 = 0d123s;\nlong i64 = 0d123l;\n</code></pre>"},{"location":"language/number-formats/#binary-format-base-2","title":"Binary format (base 2)","text":"Spice<pre><code>int i32 = 0b1010;\nshort i16 = 0b1010s;\nlong i64 = 0b1010l;\n</code></pre>"},{"location":"language/number-formats/#hexadecimal-format-base-16","title":"Hexadecimal format (base 16)","text":"Spice<pre><code>int i32 = 0xA76E;\nshort i16 = 0xA76Es;\nlong i64 = 0xA76El;\n</code></pre>"},{"location":"language/number-formats/#octal-format-base-8","title":"Octal format (base 8)","text":"Spice<pre><code>int i32 = 0o1274;\nshort i16 = 0o1274s;\nlong i64 = 0o1274l;\n</code></pre>"},{"location":"language/operator-overloading/","title":"Operator Overloading","text":"<p>Spice allows overloading operators for custom struct types. Currently, this works for the operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>[]</code>, <code>++</code> (postfix) and <code>--</code> (postfix). In the future, more operators will be supported for overloading.</p>"},{"location":"language/operator-overloading/#usage","title":"Usage","text":"<p>Overloading operators works like this: Spice<pre><code>type Size alias long;\n\ntype Counter struct {\n    Size value\n}\n\np Counter.ctor(long initialValue = 0l) {\n    this.value = initialValue;\n}\n\nf&lt;Size&gt; Counter.getValue() {\n    return this.value;\n}\n\n/**\n * Here we define the plus operator for lhs of type Counter and rhs of type Counter\n *\n * @param c1 Counter 1\n * @param c2 Counter 2\n * @return New counter with the sum of c1 and c2\n */\nf&lt;Counter&gt; operator+(const Counter&amp; c1, const Counter&amp; c2) {\n    return Counter(c1.value + c2.value);\n}\n\nf&lt;int&gt; main() {\n    Counter counter1 = Counter(2l);\n    Counter counter2 = Counter(3l);\n    printf(\"Counter1 value: %d\\n\", counter1.getValue());\n    printf(\"Counter2 value: %d\\n\", counter2.getValue());\n    Counter counter3 = counter1 + counter2; // Here we call the overloaded operator\n    printf(\"Counter3 value: %d\\n\", counter3.getValue());\n}\n</code></pre></p>"},{"location":"language/operator-precedence/","title":"Operator Precedence","text":"<p>The following table shows how Spice prioritizes the supported operators. The list is sorted top to bottom in descending precedence.</p>"},{"location":"language/operator-precedence/#precedence-table","title":"Precedence table","text":"Precedence Operator Description Associativity Modifying 1 <code>a()</code> Function/procedure call left to right no 1 <code>::</code> Scope access operator left to right no 1 <code>.</code> Member access operator left to right no 1 <code>a[]</code> Subscript operator left to right no 1 <code>a++</code> Postfix increment operator left to right yes 1 <code>a--</code> Postfix decrement operator left to right yes 2 <code>-</code> Unary minus operator right to left no 2 <code>++a</code> Prefix increment operator right to left yes 2 <code>--a</code> Prefix decrement operator right to left yes 2 <code>!</code> Logical not operator right to left no 2 <code>~</code> Bitwise not operator right to left no 2 <code>*</code> Indirection operator right to left no 2 <code>&amp;</code> Address-of operator right to left no 3 <code>cast&lt;type&gt;()</code> Type cast operator right to left no 4 <code>*</code> Multiplication left to right no 4 <code>/</code> Division left to right no 4 <code>%</code> Remainder left to right no 5 <code>+</code> Addition left to right no 5 <code>-</code> Subtraction left to right no 6 <code>&lt;&lt;</code> Bitwise left shift operator left to right no 6 <code>&gt;&gt;</code> Bitwise right shift operator left to right no 7 <code>&lt;</code> Relational less operator left to right no 7 <code>&gt;</code> Relational greater operator left to right no 7 <code>&lt;=</code> Relational less equal operator left to right no 7 <code>&gt;=</code> Relational greater equal operator left to right no 8 <code>==</code> Equal operator left to right no 8 <code>!=</code> Not equal operator left to right no 9 <code>&amp;</code> Bitwise and operator left to right no 10 <code>^</code> Bitwise or operator left to right no 11 <code>|</code> Bitwise or operator left to right no 12 <code>&amp;&amp;</code> Logical and operator left to right no 13 <code>||</code> Logical or operator left to right no 14 <code>a?b:c</code> Ternary conditional right to left no 15 <code>=</code> Assign operator right to left yes 15 <code>+=</code> Compound sum assign operator right to left yes 15 <code>-=</code> Compound difference assign operator right to left yes 15 <code>*=</code> Compound product assign operator right to left yes 15 <code>/=</code> Compound quotient assign operator right to left yes 15 <code>%=</code> Compound remainder assign operator right to left yes 15 <code>&lt;&lt;=</code> Compound shift left assign operator right to left yes 15 <code>&gt;&gt;=</code> Compound shift right assign operator right to left yes 15 <code>&amp;=</code> Compound bitwise and assign operator right to left yes 15 <code>|=</code> Compound bitwise or assign operator right to left yes 15 <code>^=</code> Compound bitwise xor assign operator right to left yes 16 <code>,</code> Comma left to right no"},{"location":"language/pointers/","title":"Pointers","text":"<p>Spice supports pointers by providing the address-of operator <code>&amp;</code> and indirection operator <code>*</code>.  For any primitive or custom data type you can also use the respective pointer type. For the <code>int</code> type, the pointer type is <code>int*</code>.</p>"},{"location":"language/pointers/#usage","title":"Usage","text":"<p>See an example here: Spice<pre><code>int variable = 1234;\nint* variablePtr = &amp;variable;\nprintf(\"Value: %d, Pointer: %p\", *variablePtr, variablePtr);\n</code></pre></p> <p>Here is a more complex example where pointers are used to pass a reference of a person to a procedure and modify a field.</p> Spice<pre><code>type Person struct {\n    string firstName\n    string lastName\n    int age\n}\n\np birthday(Person* person) {\n    person.age++;\n}\n\nf&lt;int&gt; main() {\n    dyn mike = Person { \"Mike\", \"Miller\", 32 };\n    printf(\"Age before birthday: %d\\n\", mike.age);\n    birthday(&amp;mike);\n    printf(\"Age after birthday: %d\", mike.age);\n}\n</code></pre> <p>Multiple pointers</p> <p>Spice also supports the usage of double, triple, ... pointers like <code>char***</code> or types like <code>int*[]*</code>. Please use such types sparingly and only where necessary, due to readability reasons.  To get the pointer to the pointer to an integer, you can use <code>&amp;&amp;intVariable</code> and <code>**doubleIntPtr</code> in reverse.  The member access operator automatically de-references the left side, no matter how many indirections there are.</p>"},{"location":"language/primitive-types/","title":"Primitive data types","text":"<p>Spice supports eight different primitive data types out of the box: <code>double</code>, <code>int</code>, <code>short</code>, <code>long</code>, <code>byte</code>, <code>char</code>, <code>string</code> and <code>bool</code>. In addition, there is a builtin type-inferred type, called <code>dyn</code>. Let us take a look at each one individually!</p>"},{"location":"language/primitive-types/#the-double-data-type","title":"The <code>double</code> data type","text":"<p>Doubles are signed double-precision 64-bit IEEE 754 floating point numbers.</p>"},{"location":"language/primitive-types/#variables","title":"Variables","text":"<p>In Spice, variables of type <code>double</code> can be defined like this: Spice<pre><code>double variable1 = 56.9042;\n\ndouble variable2;\nvariable2 = -0.2349;\n</code></pre></p>"},{"location":"language/primitive-types/#literals","title":"Literals","text":"<p>Double literals require a decimal separator, may have a preceding sign and the scientific notation is supported.</p> <p>They must match the following regular expression: Text Only<pre><code>[-]?[0-9]*[.][0-9]+([eE][+-]?[0-9]+)?\n</code></pre></p> <p>Examples: Spice<pre><code>-0.5\n611.456\n2.51e-11\n</code></pre></p>"},{"location":"language/primitive-types/#the-int-data-type","title":"The <code>int</code> data type","text":"<p>Integers are whole numbers of 32-bit. Signed integers have a range from a min of -2,147,483,648 to a max of 2,147,483,647. Unsigned integers have a range from a min of 0 to a max of 4,294,967,295.</p>"},{"location":"language/primitive-types/#variables_1","title":"Variables","text":"<p>In Spice, variables of type <code>int</code> can be defined like this: Spice<pre><code>int variable1 = 903;\n\nint variable2;\nvariable2 = -2;\n\nunsigned int variable3 = 4294967295u;\n</code></pre></p>"},{"location":"language/primitive-types/#literals_1","title":"Literals","text":"<p>Integer literals may have a preceding sign. The literal can be noted in decimal, binary, hexadecimal or octal system, each with its respective prefix and number/letter range. For unsigned int literals, the suffix <code>u</code> can be appended. Scientific notation is currently not supported.</p> <p>They must match the following regular expression: Text Only<pre><code>INT_LIT := [-]?(DEC_LIT | BIN_LIT | HEX_LIT | OCT_LIT)[u]?;\nDEC_LIT := ([0][dD])?[0-9]+;\nBIN_LIT := [0][bB][01]+;\nHEX_LIT := [0][xXhH][0-9a-fA-F]+;\nOCT_LIT := [0][oO][0-7]+;\n</code></pre></p> <p>Examples: Spice<pre><code>123\n-5\n0D6\n0b101\n0xf6a9\n0o71037u\n</code></pre></p>"},{"location":"language/primitive-types/#the-short-data-type","title":"The <code>short</code> data type","text":"<p>Shorts are whole numbers of 16-bit. Signed shorts have a range from a min of -32,768 to a max of 32,767. Unsigned shorts have a range from a min of 0 to a max of 65535.</p>"},{"location":"language/primitive-types/#variables_2","title":"Variables","text":"<p>In Spice, variables of type <code>short</code> can be defined like this: Spice<pre><code>short variable1 = 15s;\n\nshort variable2;\nvariable2 = 0s;\n\nunsigned short variable3 = 65535us;\n</code></pre></p>"},{"location":"language/primitive-types/#literals_2","title":"Literals","text":"<p>Short literals may have a preceding sign. The literal can be noted in decimal, binary, hexadecimal or octal system, each with its respective prefix and number/letter range. For unsigned short literals, the suffix <code>u</code> can be appended. The literal must end with the suffix <code>s</code>. Scientific notation is currently not supported.</p> <p>They must match the following regular expression: Text Only<pre><code>SHORT_LIT := [-]?(DEC_LIT | BIN_LIT | HEX_LIT | OCT_LIT)[u]?s;\nDEC_LIT := ([0][dD])?[0-9]+;\nBIN_LIT := [0][bB][01]+;\nHEX_LIT := [0][xXhH][0-9a-fA-F]+;\nOCT_LIT := [0][oO][0-7]+;\n</code></pre></p> <p>Examples: Spice<pre><code>0s\n-87s\n0d45us\n0b0010s\n0x76cbus\n0o04324s\n</code></pre></p>"},{"location":"language/primitive-types/#the-long-data-type","title":"The <code>long</code> data type","text":"<p>Longs are whole numbers of 64-bit. Signed long have a range from a min of -9,223,372,036,854,775,808 to a max of 9,223,372,036,854,775,807. Unsigned integers have a range from a min of 0 to a max of 18,446,744,073,709,551,615.</p>"},{"location":"language/primitive-types/#variables_3","title":"Variables","text":"<p>In Spice, variables of type <code>long</code> can be defined like this: Spice<pre><code>long variable1 = 12492309573l;\n\nlong variable2;\nvariable2 = -34945968l;\n\nunsigned long variable3 = 18446744073709551615ul;\n</code></pre></p>"},{"location":"language/primitive-types/#literals_3","title":"Literals","text":"<p>Long literals may have a preceding sign. The literal can be noted in decimal, binary, hexadecimal or octal system, each with its respective prefix and number/letter range. For unsigned long literals, the suffix <code>u</code> can be appended. The literal must end with the suffix <code>l</code>. Scientific notation is currently not supported.</p> <p>They must match the following regular expression: Text Only<pre><code>LONG_LIT := [-]?(DEC_LIT | BIN_LIT | HEX_LIT | OCT_LIT)[u]?l;\nDEC_LIT := ([0][dD])?[0-9]+;\nBIN_LIT := [0][bB][01]+;\nHEX_LIT := [0][xXhH][0-9a-fA-F]+;\nOCT_LIT := [0][oO][0-7]+;\n</code></pre></p> <p>Examples: Spice<pre><code>9283423923l\n-435987l\n0d7539ul\n0b11001ul\n0x7821l\n0o6666ul\n</code></pre></p>"},{"location":"language/primitive-types/#the-byte-data-type","title":"The <code>byte</code> data type","text":"<p>Bytes are unsigned whole numbers of 8-bit, which have a range from a min of 0 to a max of 255.</p>"},{"location":"language/primitive-types/#variables_4","title":"Variables","text":"<p>In Spice, variables of type <code>byte</code> can be defined like this: Spice<pre><code>byte variable1 = cast&lt;byte&gt;(11);\n\nbyte variable2;\nvariable2 = cast&lt;byte&gt;(12);\n</code></pre></p>"},{"location":"language/primitive-types/#literals_4","title":"Literals","text":"<p>There are no byte literals in Spice. Use type casting to cast an int, short or long literal to a byte.</p> Spice<pre><code>byte b = cast&lt;byte&gt;(123u);\n</code></pre>"},{"location":"language/primitive-types/#the-char-data-type","title":"The <code>char</code> data type","text":"<p>Chars are unsigned whole numbers of 8-bit, which have a range from a min of 0 to a max of 255. The value of a char represents the UTF-8 sign of the  8-bit integer value.</p>"},{"location":"language/primitive-types/#variables_5","title":"Variables","text":"<p>In Spice, variables of type <code>char</code> can be defined like this: Spice<pre><code>char variable1 = 'A';\n\nchar variable2;\nvariable2 = '.';\n</code></pre></p>"},{"location":"language/primitive-types/#literals_5","title":"Literals","text":"<p>Char literals are noted either as a single character or a single escape sequence, enclosed in single quotes.</p> <p>They must match the following regular expression: Text Only<pre><code>'([^'\\\\\\r\\n]|\\\\.)'\n</code></pre></p> <p>Examples: Spice<pre><code>'c'\n'\\n'\n</code></pre></p>"},{"location":"language/primitive-types/#the-string-data-type","title":"The <code>string</code> data type","text":"<p>Strings are immutable sequences of 8-bit integers (chars) and contain text-like information. The length of a string is unlimited.</p> <p>Note</p> <p>This type of string is immutable. So if you want to mutate your string at runtime, you can use the builtin String data type.</p> <p>Tip</p> <p>Use the <code>string</code> primitive type over the <code>String</code> builtin type as much as possible, due to its advantages in runtime performance. The usage of the <code>String</code> builtin type is only recommended, when you need to modify the value of the string at runtime.</p>"},{"location":"language/primitive-types/#variables_6","title":"Variables","text":"<p>In Spice, variables of type <code>string</code> can be defined like this: Spice<pre><code>string variable1 = \"test string\";\n\nstring variable2;\nvariable2 = \"Hello World!\";\n</code></pre></p>"},{"location":"language/primitive-types/#literals_6","title":"Literals","text":"<p>String literals are noted as a sequence of character and/or escape sequences, enclosed in double quotes.</p> <p>They must match the following regular expression: Text Only<pre><code>\"([^\"\\\\\\r\\n]|\\\\.)*\"\n</code></pre></p> <p>Examples: Spice<pre><code>\"this is a test\"\n\"\\n\\t\\r\\\"' hello\"\n</code></pre></p>"},{"location":"language/primitive-types/#the-bool-data-type","title":"The <code>bool</code> data type","text":"<p>Booleans are 1-bit integers and can be assigned with the exactly two values: <code>true</code> or <code>false</code>.</p> <p>Additional information</p> <p>Many language components like if statements, for loops, while loops, etc. use the <code>bool</code> data type as evaluation unit for conditions. You can find more information about that in the respective sections.</p>"},{"location":"language/primitive-types/#variables_7","title":"Variables","text":"<p>In Spice, variables of type <code>bool</code> can be defined like this: Spice<pre><code>bool variable1 = true;\n\nbool variable2;\nvariable2 = false;\n</code></pre></p>"},{"location":"language/primitive-types/#literals_7","title":"Literals","text":"<p>Bool literals are either the keyword <code>true</code> or <code>false</code>.</p>"},{"location":"language/primitive-types/#the-dyn-data-type","title":"The <code>dyn</code> data type","text":"<p>The <code>dyn</code> data type (<code>dyn</code> stands for dynamic) is a more unconventional data type. The concrete type of a <code>dyn</code> variable or field gets inferred at compile time so that the language stays type-safe. This also means, that once you assign a value to a <code>dyn</code> variable, the type is pinned and can't be inferred anymore. Assigning a value of another type to the same variable will result in a compile error.</p> <p>Usage of the dyn data type</p> <p>The dyn data type can not be used everywhere. Function arguments can only be declared as <code>dyn</code>, when they have a default value attached to them, from which the type can be inferred. For more information about functions, please visit the respective documentation section.</p>"},{"location":"language/primitive-types/#variables_8","title":"Variables","text":"<p>Dyn variables can be defined like this:</p> Spice<pre><code>dyn variable1 = 1.24;\ndyn variable2 = -67;\ndyn variable3;\ndyn variable4 = false;\n\nvariable3 = \"demo string\";\n</code></pre>"},{"location":"language/procedures/","title":"Procedures","text":"<p>Spice distinguishes strictly between functions and procedures. Procedures are concise and enclosed blocks of code, which a programmer can define within his source code. Each procedure holds a set of instructions to execute in the stated order. Other than functions, procedures do not have a return value. The paradigm here is, that a function calculates and returns something whereas a procedure executes some action.</p>"},{"location":"language/procedures/#usage","title":"Usage","text":"<p>Procedures in Spice can be defined like this: Spice<pre><code>p procedureName() {\n    ... // Do something\n}\n</code></pre></p> <p>Spice also allows you to pass arguments to a procedure. This arguments may also have default values, which can then be omitted when calling the procedure. </p> <p>Note</p> <p>Optional arguments have to go after mandatory arguments in the procedure head.</p>"},{"location":"language/procedures/#example-with-default-parameter-value","title":"Example with default parameter value","text":"<p>Here, the second argument is one with a default value attached. Spice<pre><code>p demoProcedure(int arg1, bool arg2 = false) {\n    ... // Do something with the arguments\n}\n</code></pre></p> <p>This procedure could get called like so: Spice<pre><code>demoProcedure(10);\ndemoProcedure(7, true);\n</code></pre></p> <p>Tip</p> <p>If you want to calculate something and need to return a value to the caller, please consider to use functions instead of procedures.</p>"},{"location":"language/references/","title":"References","text":"<p>In addition to pointers, Spice supports references. Under the hood, this works with non-nullable pointers.</p>"},{"location":"language/references/#usage-local-variables","title":"Usage - local variables","text":"<p>References can not be declared without initializing. Only declaring with immediate initialization is valid:</p> Spice<pre><code>int variable = 123;\nint&amp; variableReference = variable;\nvariableReference++;\nprintf(\"%d\", variable); // Prints 124\n</code></pre> <p>Whenever an assign operator is applied to the reference, not the reference is mapped to a new variable. Instead, the referenced value gets assigned. Therefore, the reference itself can only be assigned once, namely at declaration.</p>"},{"location":"language/references/#usage-function-parameters-return-types","title":"Usage - function parameters / return types","text":"<p>References can be used as function parameters and return types. This is useful for passing large objects without copying them:</p> Spice<pre><code>type LargeStruct struct { /* many large fields */ }\n\nf&lt;LargeStruct&amp;&gt; returnSelf(LargeStruct&amp; s) {\n    return s;\n}\n\nf&lt;int&gt; main() {\n    LargeStruct s;\n    LargeStruct&amp; s2 = returnSelf(s);    \n}\n</code></pre>"},{"location":"language/references/#usage-struct-fields","title":"Usage - struct fields","text":"<p>Struct fields can also be of type reference:</p> Spice<pre><code>type T dyn;\ntype A&lt;T&gt; struct {\n    T&amp; data\n}\nf&lt;int&gt; main() {\n    double d = 23.456;\n    dyn a = A&lt;double&gt;{d};\n}\n</code></pre>"},{"location":"language/structs/","title":"Structs","text":"<p>Spice offers support for C-like structs to aggregate variables in groups.</p>"},{"location":"language/structs/#usage","title":"Usage","text":"<p>To declare a <code>struct</code>, list all field types with names like this:</p> Spice<pre><code>type Person struct {\n    string firstName\n    string lastName\n    int age\n}\n</code></pre> <p>Structs can only be declared in the global scope, like functions and procedures.</p> <p>For creating an instance of the declared struct, you can pass values for either all or none of the fields in curly braces. To access a field of the instance, you can address the field by its name:</p> Spice<pre><code>type Person struct {\n    string firstName\n    string lastName\n    int age\n}\n\nf&lt;int&gt; main() {\n    Person john = Person { \"John\", \"Doe\", 46 };\n    john.age = 47;\n    printf(\"John's age: %d\", john.age);\n}\n</code></pre>"},{"location":"language/switch-statements/","title":"Switch Statements","text":"<p>Switch statements in Spice can be used to execute different code paths based on the value of a variable. This is similar to <code>switch</code> statements in other languages, but with some differences. The expression in the <code>switch</code> statement can be of type <code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>, <code>char</code> or <code>bool</code> and the individual match expressions need to be literals of the respective type.</p>"},{"location":"language/switch-statements/#usage","title":"Usage","text":"<p>Here's a simple example for an <code>switch</code> statement: Spice<pre><code>switch number {\n    case 0: { printf(\"Zero\"); }\n    case 1: { printf(\"One\"); }\n    case 2: { printf(\"Two\"); }\n    case 3: { printf(\"Three\"); }\n    case 4: { printf(\"Four\"); }\n    case 5: { printf(\"Five\"); }\n    case 6: { printf(\"Six\"); }\n    case 7: { printf(\"Seven\"); }\n    case 8: { printf(\"Eight\"); }\n    case 9: { printf(\"Nine\"); }\n    default: { printf(\"NaN\"); }\n}\n</code></pre> Each <code>case</code> branch gets executed, if the value of the <code>switch</code> statement matches the value of the case branch. If no case branch matches, the optional <code>default</code> branch gets executed. The default branch must be the last branch in the <code>switch</code> statement, the order of case branches does not matter.</p> <p>Optional parentheses</p> <p>As with the for, foreach and while loops, the parentheses around the head of the <code>switch</code> statement are optional.</p> <p>Let's take a look at a switch statement: Spice<pre><code>switch (input) {\n    case 0, 2, 4, 6, 8: { printf(\"Even\"); }\n    case 1, 3, 5, 7, 9: { printf(\"Odd\"); }\n}\n</code></pre> This piece of code is a bit pointless, but you can see, that you can also assign two constant values to result in the same branch being executed.</p>"},{"location":"language/switch-statements/#fallthrough","title":"Fallthrough","text":"<p>In Spice, the <code>switch</code> statement does not fall through by default. This means, that you don't need to use the <code>break</code> keyword to prevent the next case from being executed, like in other languages. In Spice, you have to use the <code>fallthrough</code> keyword to fall through to the next case branch. This originated from the assumption, that you more often want to execute one branch, instead of having fallthrough behavior.</p> <p>The fallthrough keyword can be used like this: Spice<pre><code>int i = 1;\nswitch i {\n    case 1, 2: {\n        printf(\"1 or 2\\n\");\n        fallthrough;\n    }\n    case 6, 9: {\n        printf(\"6 or 9\\n\");\n    }\n    default: {\n        printf(\"Default\\n\");\n    }\n}\n</code></pre> The <code>fallthrough</code> keyword ensures that in the above example, the <code>case 6, 9</code> branch gets executed, even though the value of <code>i</code> is <code>1</code> or <code>2</code> and the respective branch was executed beforehand.</p>"},{"location":"language/threads/","title":"Threads","text":"<p>Spice supports multithreading. It is very easy to use and very lightweight. Under the hood Spice uses posix pthreads to realize multi-threading.</p>"},{"location":"language/threads/#usage","title":"Usage","text":"<p>A simple worker thread can be spawned like this:</p> Spice<pre><code>import \"std/os/thread\";\n\nf&lt;int&gt; main() {\n    Thread thread = Thread(p() [[async]] {\n        // Do something\n    });\n    thread.run();\n}\n</code></pre> <p>Please always add the <code>[[async]]</code> attribute to the thread routine. This will ensure, that the thread routine is executed in a thread-safe manner. The <code>run()</code> method will start the thread. The thread will run until the thread routine returns.</p> <p>To join a thread to the main thread, use the <code>join()</code> method:</p> Spice<pre><code>import \"std/os/thread\";\n\nf&lt;int&gt; main() {\n    Thread thread1 = Thread(p() [[async]] {\n        // Do something\n    });\n    thread1.run();\n    Thread thread2 = Thread(p() [[async]] {\n        // Do something\n    });\n    thread2.run();\n    // Do something\n    thread1.join();\n    thread2.join();\n}\n</code></pre> <p>To get the ID of a thread, use the <code>getId()</code> method. This only works, if <code>run()</code> was already called on the thread object. To get the ID of the current thread (i.e. within the thread routine), you can call the static <code>getThreadId()</code> function:</p> Spice<pre><code>import \"std/os/thread\";\n\nf&lt;int&gt; main() {\n    Thread thread1 = Thread(p() [[async]] {\n        // Do something\n    });\n    Thread thread2 = Thread(p() [[async]] {\n        // Do something\n    });\n    thread2.run();\n    thread1.run();\n    printf(\"Thread 1 ID: %d\\n\", thread1.getId());\n    printf(\"Thread 2 ID: %d\\n\", thread2.getId());\n}\n</code></pre>"},{"location":"language/threads/#thread-pools","title":"Thread pools","text":"<p>Spice offers thread pools out of the box via the <code>std/os/threadpool</code> module. A thread pool is a collection of worker threads of a fixed size. The threads are spawned when the thread pool is created and are kept alive until the thread pool is destroyed. The threads are idle until a task is enqueued to the thread pool. The thread pool then assigns the task to one of the workers. The thread pool can be used like this:</p> Spice<pre><code>import \"std/os/threadpool\";\n\nf&lt;int&gt; main() {\n    ThreadPool tp = ThreadPool(3s); // Create a thread pool with 3 worker threads\n    // Enque tasks to the thread pool, that will run in parallel\n    tp.enqueue(p() [[async]] {\n        delay(50);\n        printf(\"Hello from task 1\\n\");\n    });\n    tp.enqueue(p() [[async]] {\n        delay(100);\n        printf(\"Hello from task 2\\n\");\n    });\n    tp.enqueue(p() [[async]] {\n        delay(150);\n        printf(\"Hello from task 3\\n\");\n    });\n    tp.start(); // This will kick off the worker threads and immediately return\n}\n</code></pre> <p>To pause the thread pool, use the <code>pause()</code> method. This will pause all worker threads. To resume the thread pool, use the <code>resume()</code> method. This will resume all worker threads. To stop the thread pool, use the <code>stop()</code> method. The worker threads will continue the current task and then exit. You can start the thread pool again by calling the <code>start()</code> method at any time.</p> <p>To wait for all tasks to finish, use the <code>join()</code> method. This will block the current thread until all tasks in the thread pool are finished.</p>"},{"location":"language/threads/#mutexes","title":"Mutexes","text":"<p>ToDo</p>"},{"location":"language/while-loops/","title":"While Loops","text":"<p>While loops are designed to do something until a certain condition evaluates to <code>false</code>. This means, that a while loop could also run infinitely when the condition never gets fulfilled.  Like the if statement, the condition of the <code>while</code> loop must evaluate to a boolean value, but can hold complex, nested expressions.</p>"},{"location":"language/while-loops/#usage","title":"Usage","text":"<p>Here is an example of a simple <code>while</code> loop: Spice<pre><code>int counter = 0;\nwhile counter &lt; 20 {\n    printf(\"Loop run %d\", counter);\n    counter++;\n}\n</code></pre></p> <p>Optional parentheses</p> <p>As with the if statement, for loop and foreach loop, the parentheses around the head of the <code>while</code> loop are optional.</p> <p>If you wanted to intentionally achieve an endless loop, you would write something like this: Spice<pre><code>while true {\n    printf(\"This is gonna run forever ...\");\n}\n</code></pre></p> <p>Usage of loop alternatives</p> <p>If you somehow know how many times you want to execute something, we recommend you to use a for loop instead. If you want to iterate over a container of items, consider using the foreach loop.</p>"}]}